<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"config_config.js.html":{"id":"config_config.js.html","title":"Source: config/config.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: config/config.js /** * Config data pulled from the .env file * and some globally accessible internal variables * @module config/config * @version 2.0 */ module.exports = { /** * dotenv is an Object of the key value pairs from ~/.polyglot/.env * @type {Object} */ dotenv: {}, /** * MongoDB is connected True/False * @type {boolean} */ dbConnected: false, /** * MQTT is connected True/False * @type {boolean} */ mqttConnected: false, /** * Array of NodeServerModel objects kept in resident memory as reflection of their database models. * This allows for direct calling of NodeServerModel objects via nodeServers[profileNum]. The Array index * correlates to the NodeServer profileNum for ease of use. e.g. LiFX nodeserver with the profileNum of 8 * can be called via nodeServers[8].save() to save the NodeServer changes to the db for example. * @type {Array} */ nodeServers: new Array(11), /** * Settings Loaded from the ~/.polyglot/.env file using the dotenv NodeJS module. You SHOULD NEVER MODIFY THIS IN THE SOURCE. Just use the .env * isyHost = '192.168.1.10' * isyPort = '80' * isyUsername = 'admin' * isyPassword = 'password' * isyHttps = true/false (This isn't tested yet) * mqttHost = '192.168.1.12' (This CANNOT be 'localhost' or '127.0.0.1' as it is passed to the frontend for websocket connections. IT MUST BE THE HOST IP) * mqttPort = '1883' (Default is 1883) * mqttWSPort = '8083' (Default is 8083) * @type {Object} */ settings: {}, /** * SSL Key and Cert Data, read at startup from ~/.polylot/ssl/ using the files polyglot.crt and polyglot.key */ sslKey: '', sslCrt: '', clientTails: {}, installedNSTypes: [], } × Search results Close "},"config_passport.js.html":{"id":"config_passport.js.html","title":"Source: config/passport.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: config/passport.js const JwtStrategy = require('passport-jwt').Strategy const ExtractJwt = require('passport-jwt').ExtractJwt const UserModel = require('../models/user') const config = require('../config/config') /** * The passport module to wrap all authenticated functions * that require the token to be accessed. * @module config/passport * @version 2.0 */ /** * Function to create the JWT Strategy for Passport. * @method * @param {module} passport - The Passport module is passed in to create a new JwtToken Strategy for authentication via header tokens. */ module.exports = function(passport){ let opts = {} opts.jwtFromRequest = ExtractJwt.fromAuthHeaderWithScheme('jwt') opts.secretOrKey = config.settings.secret passport.use(new JwtStrategy(opts, (jwt_payload, done) =&gt; { UserModel.getUserById(jwt_payload.data._id, (err, user) =&gt; { if (err) { return done(err, false) } if (user) { return done(null, user) } else { return done(null, false) } }) })) } × Search results Close "},"models_nodeserver.js.html":{"id":"models_nodeserver.js.html","title":"Source: models/nodeserver.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: models/nodeserver.js const mongoose = require('mongoose') //const randomstring = require('randomstring') const logger = require('../modules/logger') const config = require('../config/config') const helpers = require('../modules/helpers') const mqtt = require('../modules/mqttc') const mqtts = require('../modules/mqtts') const child = require('../modules/children') const isy = require('../modules/isy') const os = require('os') const fs = require('fs-extra') const path = require('path') const async = require('async') /** * NodeServer Model and Parent Class. AddNS uses 'new NodeServerModel' to reference the NodeServerSchema parent class to create a new MongoDB document via Mongoose * @module models/nodeserver * @version 2.0 */ /** * MongoDB - Driver Child Schema * @class DriverSchema * @extends NodeSchema * @param {string} driver - Driver Name e.g. 'ST', 'RR', 'GV1', etc * @param {string} value - String representation of the value of the driver. * @param {number} uom - Integer of the UOM representing the value of the driver. */ const DriverSchema = mongoose.Schema({ driver: { type: String, required: true }, value: { type: String, default: null }, uom: { type: Number, default: null } }) /** * MongoDB - Nodes Child Schema * @class NodeSchema * @extends NodeServerModel * @param {string} address - Node address value e.g. 'lifxcontrol' * @param {boolean} added - Represents if the node is added and present in the ISY. * @param {boolean} enabled - Represents the enabled state of the node. * @param {string} name - Descriptive name of the node. * @param {string} node_def_id - Node Definition ID represented in the profile.zip for this node type. * @param {string} time_added - DateString in epoch of when the node was added to Polyglot * @param {string} primary - The node address of the nodes primary parent node. This could be itself in some cases. * @param {boolean} isprimary - Is this node a primary for other nodes. * @param {Object} drivers - Array of DriverSchema Objects */ const NodeSchema = mongoose.Schema({ address: { type: String, required: true }, added: { type: Boolean, default: false }, enabled: { type: Boolean, default: true }, name: { type: String, required: true }, node_def_id: { type: String, default: null }, time_added: { type: String, default: + new Date() }, primary: { type: String, default: null }, isprimary: { type: Boolean, default: false }, drivers: [DriverSchema] }) /** * MongoDB - NodeServer Parent Schema for creating a new NodeServer Database Object * @class NodeServerModel * @param {string} name - NodeServer name that is displayed in Polyglot. e.g. 'LiFX' or 'Nest' * @param {string} profileNum - ProfileNumber of the NodeServer. This must be a unique number between 1 - 10 that is not already defined in ISY. * @param {boolean} encryptPayload - Should we encrypt the payload using our .env secret? *[NOT IMPLEMENTED YET]* * @param {string} token - Encryption token taken from the .env file and saved to the DB *[NOT IMPLEMENTED YET]* * @param {string} time_added - DateString in epoch of when the NodeServer was added to Polyglot * @param {boolean} isConnected - Is Polyglot Connected to MQTT? * @param {string} logPrefix - Allows for custom logPrefixes to be defined per NodeServer if needed. * @param {Object} nodes - Array of NodeSchema Objects */ const NodeServerSchema = mongoose.Schema({ name: { type: String, required: true }, profileNum: { type: String, required: true, unique: true }, encryptPayload: { type: Boolean, default: false }, token: { type: String, default: null }, time_added: { type: String, default: + new Date() }, isConnected: { type: Boolean, default: false }, logPrefix: { type: String, default: null }, customParams: { type: Object, default: {} }, type: { type: String, default: 'local' }, logFile: { type: String, default: 'logs/debug.log' }, homeDir: { type: String, default: '' }, nodes: [NodeSchema] }) NodeServerSchema.statics = { /** * Sends an update to the frontend topic on detection of a change in NodeServer properties or sub properties like driver updates or state changes. * @method * @alias NodeServerModel.sendUpdate * @memberof module:models/nodeserver * @returns {object} response - MQTT Message sent to the frontends. e.g.: {&quot;nodeservers&quot;:[{&quot;name&quot;:&quot;LiFX&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;nodes&quot;:[{&quot;address&quot;:&quot;lifx_1234&quot;,&quot;name&quot;:&quot;LIFX_Lamp&quot;,&quot;_id&quot;:&quot;59338d1c2930bf7cc92842d1&quot;,&quot;drivers&quot;: [{&quot;driver&quot;:&quot;ST&quot;,&quot;_id&quot;:&quot;59338624cd92117adb9349ca&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;123.3&quot;},{&quot;driver&quot;:&quot;GV5&quot;,&quot;_id&quot;:&quot;59338624cd92117adb9349c9&quot;,&quot;uom&quot;:23,&quot;value&quot;:&quot;10&quot;}], &quot;isprimary&quot;:true,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496550684087&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true},{&quot;address&quot;:&quot;lifx_1235&quot;, &quot;name&quot;:&quot;Z_Strip&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d941&quot;,&quot;drivers&quot;: [{&quot;driver&quot;:&quot;ST&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d943&quot;,&quot;uom&quot;:56,&quot;value&quot;:&quot;593.3&quot;}, {&quot;driver&quot;:&quot;GV1&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d942&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:false,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496552508813&quot;, &quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true}],&quot;token&quot;:null,&quot;encryptPayload&quot;:false,&quot;time_added&quot;:&quot;1496545371618&quot;,&quot;isConnected&quot;:true}]} */ sendUpdate() { let ns = config.nodeServers.filter(ns =&gt; { if (ns) return ns } ) mqtt.publish('udi/polyglot/frontend/nodeservers', {node: 'polyglot', nodeservers: ns}, {retain: true}) }, /** * Frontend called method to add a new NodeServer * @method * @alias NodeServerModel.addns * @memberof module:models/nodeserver * @param {string} name - Name of NodeServer being added * @param {number} profileNum - Profile Number of NodeServer being added * @param {addnsCallback} callback - Callback with response JSON * @returns {object} response - AddNS: {&quot;addns&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;},&quot;seq&quot;:53407} Success: {&quot;seq&quot;:53407,&quot;response&quot;:{&quot;success&quot;:true,&quot;msg&quot;:&quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;,&quot;nodeserver&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;}}} Fail: {&quot;seq&quot;:53408,&quot;response&quot;:{&quot;success&quot;:false,&quot;msg&quot;:&quot;NodeServer with that Profile Number already exists.&quot;}} */ addns(data, callback) { let nsData = { name: data.name, profileNum: data.profileNum, logPrefix: `${data.name}(${data.profileNum}):`, type: data.type, } if (data.type === 'local') { let nsDir = `${os.homedir()}/.polyglot/nodeservers/${data.path}/` nsData['homeDir'] = nsDir if (fs.existsSync(nsDir + '/server.json') &amp;&amp; fs.existsSync(nsDir + '/profile.zip')) { logger.debug('NS: Add Nodeserver, found server.json and profile.zip... proceeding.') } else { if (callback) { return callback(null, {success: false, msg: `${data.name} local NodeServer server.json or profile.zip not found.`}) } else { return } } } let newNodeServer = new NodeServerModel(nsData) const query = {profileNum: newNodeServer.profileNum} NodeServerModel.findOne(query, (err, node) =&gt; { if (err) { if (callback) return callback(err) } if (node) { if (callback) return callback(null, {success: false, msg: 'NodeServer with that Profile Number already exists.'}) } else { newNodeServer.installNodeServer((err, message) =&gt; { if (err) { logger.error(`${newNodeServer.logPrefix} Unable to register ${newNodeServer.name} with ISY. Reason: ${err}`) newNodeServer.remove() if (callback) return callback(null, {success: false, msg: err}) } else { newNodeServer.save((err, node) =&gt; { if (err) { if (callback) return callback(err) } if (!node) { if (callback) return callback(null, {success: false, msg: 'Failed to register NodeServer'}) } else { logger.info('Registered new ' + data.type + ' NodeServer: ' + node.name + '(' + node.profileNum + ')') config.nodeServers[node.profileNum] = newNodeServer mqtt.addSubscription(node.profileNum) NodeServerModel.sendUpdate() if (newNodeServer.type === 'local') { logger.info(`Waiting 60 seconds for the ISY to reboot before starting ${node.name} for the first time.`) config.installedNSTypes.push(node.name) setTimeout(() =&gt; { child.runChildNodeServer(node) }, 60000) } if (callback) return callback(null, { success:true, msg: message, nodeserver: { name: node.name, profileNum: node.profileNum } }) } }) } }) } }) }, /** * Parse incoming log request messages * @method * @alias NodeServerModel.parseLog * @memberof module:models/nodeserver * @param {Object} message - Incoming JSON parsed object from the frontend. Only commands accepted are 'addns' and 'delns' currently */ parseLog(message) { if (message.hasOwnProperty('node')) { if (message.hasOwnProperty('start')) { if (config.clientTails.hasOwnProperty(message.node)) { config.clientTails[message.node].unwatch() delete config.clientTails[message.node] } if (message.start === 'polyglot') { const logFile = os.homedir() + '/.polyglot/log/debug.log' this.readLogAndSend(message.node, 'polyglot', logFile) //var disconnectWrapper = helpers.wrapFunction(this.removeLog, this, [message.node, config.clientTails[message.node]]) //mqtts.clientDisconnectCallbacks[message.node].push(disconnectWrapper) } else if ((config.nodeServers[message.start]) &amp;&amp; config.nodeServers[message.start].profileNum === message.start) { if (config.nodeServers[message.start].type === 'local') { const logFile = config.nodeServers[message.start].homeDir + 'logs/debug.log' this.readLogAndSend(message.node, config.nodeServers[message.start].name, logFile) } } } else if (message.hasOwnProperty('stop')) { logger.debug('NS: Stopping log dump for client: ' + message.node) if (config.clientTails.hasOwnProperty(message.node)) { config.clientTails[message.node].unwatch() } delete config.clientTails[message.node] } } else { logger.error('NS: Received malformed log request.') } }, /** * Read Log File and send to frontend client. * @method * @alias NodeServerModel.readLogAndSend * @memberof module:models/nodeserver * @param {String} node - Node Name of frontend client. * @param {String} name - Common Name of Node Server eg. LiFX * @param {String} logFile - Exact path to logfile */ readLogAndSend(node, name, logFile) { var topic = 'udi/polyglot/frontend/log/' + node logger.debug('NS: Starting log dump of ' + name + ' log file to frontend client: ' + node) //This works 1000 times faster to stream it than bulk read it first if (fs.existsSync(logFile)) { var rs = fs.createReadStream(logFile) rs.on('data', (chunk) =&gt; { var logPacket = { node: 'polyglot', log: chunk.toString('utf8') } mqtt.publish(topic, logPacket) }) rs.on('end', () =&gt; { Tail = require('tail').Tail config.clientTails[node] = new Tail(logFile) config.clientTails[node].on('line', (data) =&gt; { var logPacket = { node: 'polyglot', log: data } mqtt.publish(topic, logPacket) }) }) } }, /** * Read Log File and send to frontend client. * @method * @alias NodeServerModel.removeLog * @memberof module:models/nodeserver * @param {String} clientId - Client ID of frontend client. * @param {Object} tail - The tail instance of the logfile. */ removeLog(clientId, tail) { logger.debug('NS: Terminating log tail for frontend client: ' + clientId) tail.unwatch() }, /** * Parse incoming Frontend messages * @method * @alias NodeServerModel.parseFrontend * @memberof module:models/nodeserver * @param {Object} message - Incoming JSON parsed object from the frontend. Only commands accepted are 'addns' and 'delns' currently */ parseFrontend(message) { if (message.hasOwnProperty('addns')) { if (message.addns.hasOwnProperty('name') &amp;&amp; message.addns.hasOwnProperty('profileNum')) { NodeServerModel.addns(message.addns, (err, result) =&gt; { if (err) return logger.debug(error) if (message.hasOwnProperty('seq')) { let response = { node: 'polyglot', seq: message.seq, response: result } mqtt.publish('udi/polyglot/frontend/nodeservers', response) NodeServerModel.sendUpdate() } }) } else { logger.error('MQTT: Received Add NodeServer command. name or profileNum was missing.') } } else if (message.hasOwnProperty('delns')) { if (message.delns.hasOwnProperty('profileNum')) { if (config.nodeServers[message.delns.profileNum]) { config.nodeServers[message.delns.profileNum].deleteNodeServer((err, result) =&gt; { if (message.hasOwnProperty('seq')) { let response = { node: 'polyglot', seq: message.seq, response: { success: err ? false: true, msg: err ? err : result } } mqtt.publish('udi/polyglot/frontend/nodeservers', response) NodeServerModel.sendUpdate() } }) } else { let response = { node: 'polyglot', seq: message.seq, response: { success: false, msg: `NodeServer with the profile number: ${message.delns.profileNum} does not exist.` } } mqtt.publish('udi/polyglot/frontend/nodeservers', response) } } else { logger.error('MQTT: Received Delete NodeServer command. profileNum was missing.') } } else if (message.hasOwnProperty('customparams')) { if (message.customparams.hasOwnProperty('profileNum')) { if (config.nodeServers[message.customparams.profileNum]) { config.nodeServers[message.customparams.profileNum].customparams(message.customparams, 'customparams', (err, result) =&gt; { if (message.hasOwnProperty('seq')) { let response = { node: 'polyglot', seq: message.seq, response: { success: err ? false: true, msg: err ? err : result } } mqtt.publish('udi/polyglot/frontend/nodeservers', response) NodeServerModel.sendUpdate() } }) } else { let response = { node: 'polyglot', seq: message.seq, response: { success: false, msg: `NodeServer with the profile number: ${message.customparams.profileNum} does not exist.` } } mqtt.publish('udi/polyglot/frontend/nodeservers', response) } } else { logger.error('MQTT: Received CustomParams for NodeServer command. profileNum was missing.') } } else if (message.hasOwnProperty('nodetypes')) { NodeServerModel.getInstalledNodeTypes() } else if (message.hasOwnProperty('installns')) { child.cloneRepo(message, (err) =&gt; { if (err) { logger.error(`NS: Error - Failed to Clone NS: ${err}`) let response = { node: 'polyglot', seq: message.seq, response: { success: false, msg: err } } return mqtt.publish('udi/polyglot/frontend/nodeservers', response) } else { logger.info(`NS: Successfully cloned ${message.installns.name} into NodeServer directory.`) let response = { node: 'polyglot', seq: message.seq, response: { success: true, msg: `Clone successful. Add the ${message.installns.name} nodeserver to ISY in the &quot;Add NodeServer&quot; tab.` } } child.runInstallProcess(message.installns.name) NodeServerModel.getInstalledNodeTypes() return mqtt.publish('udi/polyglot/frontend/nodeservers', response) } }) } else if (message.hasOwnProperty('uninstallns')) { NodeServerModel.deleteNSFolder(message, (err) =&gt; { if (err) { logger.error(`NS: Error - Failed to Delete NS: ${err.response.msg}`) return mqtt.publish('udi/polyglot/frontend/nodeservers', err) } else { let response = { node: 'polyglot', seq: message.seq, response: { success: true, msg: `Delete successful. ${message.uninstallns.name} folder has been removed.` } } return mqtt.publish('udi/polyglot/frontend/nodeservers', response) } }) } else if (message.hasOwnProperty('updatens')) { child.pullRepo(message, (err) =&gt; { if (err) { logger.error(`NS: Error - Failed to Update NS: ${err}`) let response = { node: 'polyglot', seq: message.seq, response: { success: false, msg: err } } return mqtt.publish('udi/polyglot/frontend/nodeservers', response) } else { logger.info(`NS: Successfully updated ${message.updatens.name} via git.`) let response = { node: 'polyglot', seq: message.seq, response: { success: true, msg: `Update pulled Sucessfully from Git. Restart the NodeServer from the Control tab. Under Dashboard &gt; NodeServer &gt; Details` } } child.runInstallProcess(message.updatens.name) NodeServerModel.getInstalledNodeTypes() return mqtt.publish('udi/polyglot/frontend/nodeservers', response) } }) } }, deleteNSFolder(message, callback) { let response = { node: 'polyglot', seq: message.seq, response: { success: false, msg: 'name or url property not found in package' } } config.nodeServers.forEach((ns) =&gt; { if (ns.name === message.uninstallns.name) { response.response.msg = `${message.uninstallns.name} is still active. Please delete it from the Dashboard first before uninstalling it here.` return callback(response) } }) if (message.uninstallns.hasOwnProperty('name') &amp;&amp; (!(message.uninstallns.name.includes('..')))) { let nsPath = `${os.homedir()}/.polyglot/nodeservers/${message.uninstallns.name}/` try { fs.removeSync(nsPath) NodeServerModel.getInstalledNodeTypes() return callback(null) } catch (e) { logger.error(`DeleteNS Folder: Error deleting ${message.uninstallns.name} folder: ${e}`) response.response.msg = e.toString() return callback(response) } } else { response.response.msg = 'name or url property not found in package' } return callback(response) }, getInstalledNodeTypes() { var nsDir = os.homedir() + '/.polyglot/nodeservers/' let nsTypes = {} nsTypes.notInUse = [] nsTypes.installed = [] if (fs.existsSync(nsDir)) { var nsDirs = fs.readdirSync(nsDir).filter(f =&gt; fs.statSync(path.join(nsDir, f)).isDirectory()) nsDirs.forEach((nodeType) =&gt; { if (fs.existsSync(nsDir + nodeType + '/server.json')) { try { let server = require(nsDir + nodeType + '/server') if (server.hasOwnProperty('name') &amp;&amp; server.hasOwnProperty('executable')) { nsTypes.installed.push(server.name) if (!(config.installedNSTypes.includes(server.name))) { server['_folder'] = nodeType nsTypes.notInUse.push(server) } } } catch (e) { logger.error('NS: Error getting server.json required fields. name and executable are required. - ' + e) } } }) let response = { node: 'polyglot', nodetypes: nsTypes } mqtt.publish('udi/polyglot/frontend/nodeservers', response) } return nsTypes }, /** * Get all NodeServers from MongoDB * @method * @alias NodeServerModel.getAllNodeServers * @memberof module:models/nodeserver * @param {findArrayCallback} callback - Callback Passed into the Mongoose find method. * @returns {findArrayCallback} */ getAllNodeServers(callback) { return NodeServerModel.find({}, null, {sort: {'profileNum': 1}}, callback) }, /** * Get NodeServer from MongoDB by Name * @method * @alias NodeServerModel.getNodeByName * @memberof module:models/nodeserver * @param {string} name - Name of Node requested from MongoDB * @param {findCallback} callback - Callback Passed into the Mongoose find method. * @returns {findCallback} */ getNodeByName(name, callback) { let query = {name: name} return NodeServerModel.findOne(query, callback) }, /** * Get NodeServer from MongoDB by profileNum * @method * @alias NodeServerModel.getNodeByProfileNum * @memberof module:models/nodeserver * @param {number} number - profileNum of Node requested from MongoDB * @param {findCallback} callback - Callback Passed into the Mongoose find method. * @returns {findCallback} */ getNodeByProfileNum(num, callback) { const query = {profileNum: num} return NodeServerModel.findOne(query, callback) }, /** * Load all NodeServers from MongoDB on Polyglot Start-up * @method * @alias NodeServerModel.loadNodeServers * @memberof module:models/nodeserver * @param {errOnlyCallback} callback - Callback returned when complete */ loadNodeServers(callback) { NodeServerModel.getAllNodeServers((err, nodes) =&gt; { if(nodes) { var i = 0 nodes.forEach((ns) =&gt; { if ((ns.get('profileNum')) &amp;&amp; (ns.get('name')) &amp;&amp; (ns.get('type'))) { logger.debug(`NodeServer ${ns.name} [${ns.profileNum}] added to running config.`) config.nodeServers[ns.profileNum] = ns if (ns.type != 'unmanaged') { ns.getNodesFromISY() } if (ns.type === 'local') { config.installedNSTypes.push(ns.name) child.runChildNodeServer(ns) } i++ } }) logger.debug('MongoDB: ' + i + ' NodeServer(s) retrieved from database') } else { logger.debug('MongoDB: No NodeServers found in database') } NodeServerModel.sendUpdate() NodeServerModel.verifyNonManagedNodeServers() NodeServerModel.pollNonManagedServers() if (callback) { return callback(err) } }) }, /** * Check all the existing slots in the ISY for NodeServers. * @method * @alias NodeServerModel.checkExistingNodeServers * @memberof module:models/nodeserver * @param {Function} callback - Callback with an Object of NodeServers currently installed in ISY. { 1: 'LiFX', 5: 'Nest' } */ checkExistingNodeServers(callback) { let foundNS = {} isy.handleRequest('0', {api: 'profiles/ns/0/connection'}, 'restcall', true, (results) =&gt; { if (!results) { if (callback) { return callback(null, {}) } else return } try { let i = 0 if (results.isyresponse.hasOwnProperty('connections') &amp;&amp; results.statusCode === 200) { results.isyresponse.connections.connection.forEach((nodeServer) =&gt; { foundNS[nodeServer.profile] = nodeServer.name i++ }) config.nodeServers.forEach((nodeServer) =&gt; { if (nodeServer.type === 'unmanaged' ) { if (!(foundNS.hasOwnProperty(nodeServer.profileNum))) { logger.info(`NS: ${nodeServer.name} Unmanaged NodeServer no longer found in the ISY. Removing from Polyglot`) nodeServer.remove((err) =&gt; { delete config.nodeServers[nodeServer.profileNum] NodeServerModel.sendUpdate() }) } } }) callback(null, foundNS) } else { callback(null) } } catch (e) { callback({error: e}) } }) }, /** * Check all the existing slots in the ISY for NodeServers and add or remove them from our running database on Polyglot. * @method * @alias NodeServerModel.verifyNonManagedNodeServers * @memberof module:models/nodeserver */ verifyNonManagedNodeServers() { NodeServerModel.checkExistingNodeServers((err, isyNodeServers) =&gt; { if (err) { return logger.error(err) } Object.keys(isyNodeServers).forEach((key) =&gt; { const query = {profileNum: key} NodeServerModel.findOne(query, (err, node) =&gt; { if (!(node)) { let newNodeServer = new NodeServerModel({ name: isyNodeServers[key], profileNum: key, logPrefix: `${isyNodeServers[key]}(${key}):`, type: 'unmanaged' }) newNodeServer.save((err, node) =&gt; { if (err) { if (callback) return callback(err) } if (!node) { if (callback) return callback(null, {success: false, msg: 'Failed to register NodeServer'}) } else { logger.info('NS: Registered new unmanaged NodeServer: ' + node.name + '(' + node.profileNum + ')') config.nodeServers[node.profileNum] = newNodeServer NodeServerModel.sendUpdate() } }) } }) }) }) }, /** * Started on Initial DB load on program init. This polls the NodeServer list on ISY every 60 seconds and syncs. * @method * @alias NodeServerModel.verifyNonManagedNodeServers * @memberof module:models/nodeserver */ pollNonManagedServers() { setInterval(NodeServerModel.verifyNonManagedNodeServers, 5 * 60000) } } NodeServerSchema.methods = { print () { return config.nodeServers[this.profileNum] }, /** * Instance Method for NodeServer to return a JSON object of itself. * @function toJSON * @alias NodeServerModel.toJSON * @memberof module:models/nodeserver~NodeServerModel * @instance * @returns {Object} nodeserver - Returns JSON parsed Object representation of the NodeServer */ toJSON() { let {name, profileNum, nodes, token, encryptPayload, time_added, isConnected, customParams, type, logDir} = this return JSON.parse(JSON.stringify({name, profileNum, nodes, token, encryptPayload, time_added, isConnected, customParams, type, logDir})) }, /** * Instance Method for NodeServer to check input from MQTT and execute function if successful. * Valid Commands: ['status', 'addnode','removenode', 'restcall', 'request', 'config', 'connected', 'command'] * @function checkCommand * @alias NodeServerModel.checkCommand * @memberof module:models/nodeserver~NodeServerModel * @instance */ checkCommand(data){ //if (this.isConnected) { let validCommands = ['status', 'addnode','removenode', 'restcall', 'request', 'config', 'connected', 'command', 'customparams', 'installprofile', 'stop', 'start', 'restart'] for (var prop in data) { if (prop === 'node') { continue } if (validCommands.indexOf(prop) &lt; 0) { logger.error(`${this.logPrefix} ${prop} not in valid commands list`) continue } logger.info(`${this.logPrefix} Processing command: ${prop}`) if (data.hasOwnProperty(prop)) { (this[prop] || this['notfound']).call(this, data[prop], prop) } else { logger.debug(`${this.logPrefix} Property not found in input: ${data}`) } } //} else { // logger.error(`${this.logPrefix} is not connected. Make sure you send connected: true as the first message.`) //} }, /** * Instance Method for NodeServer to handle 'status' * @function status * @alias NodeServerModel.status * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming command message e.g. {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;driver&quot;: &quot;GV6&quot;, &quot;value&quot;: 50.2, &quot;uom&quot;: 20} * @param {string} command - The command received: 'status' * @returns {object} response - ONLY if an error occurs will a MQTT response message will be sent back to the NodeServer: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:404,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;9.735427ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;status&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1234 or GV18 does not exist&quot;,&quot;address&quot;:&quot;lifx_1234&quot;}}} */ status(data, command) { // Profile#, incoming json, command &quot;status&quot;, full response text (t/f) isy.handleRequest(this.profileNum, data, command, false, (result) =&gt; { if (! result) { return } if (result.statusCode === 404) { let reason = `${data.address} or ${data.driver} does not exist` this.sendResult(command, result, false, reason, {address: data.address}) logger.error(`${this.logPrefix} ${reason}`) } else if (result.statusCode === 200){ let success = false for (var node in this.nodes) { if (this.nodes[node].address === data.address) { for (var driver in this.nodes[node].drivers) { if (this.nodes[node].drivers[driver].driver === data.driver) { this.nodes[node].drivers[driver].uom = data.uom this.nodes[node].drivers[driver].value = data.value success = true this.save(() =&gt; { let reason = `${data.address} ${data.driver} set sucessfully to ${data.value}` //this.sendResult(command, result, true, reason, {address: data.address}) logger.info(`${this.logPrefix} ${reason}`) NodeServerModel.sendUpdate() }) } } } } if (!success) { let reason = `${data.address} driver ${data.driver} does not exist in the Polyglot database.` this.sendResult(command, result, false, reason, {address: data.address}) logger.error(`${this.logPrefix} ${reason}`) } } }) }, /** * Instance Method for NodeServer to handle 'command' * @function command * @alias NodeServerModel.command * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;command&quot;: &quot;DON&quot;, &quot;value&quot;: 50.2, &quot;uom&quot;: 20} * @param {string} command - The command received: 'command' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;true&quot;,&quot;status&quot;:&quot;200&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;0&quot;}}},&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;19.073624ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;command&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;lifx_1234 DON sent sucessfully with 50.2&quot;,&quot;address&quot;:&quot;lifx_1234&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;400&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;2101&quot;}}},&quot;statusCode&quot;:400,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;10.852264ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;command&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_123 or asdf does not exist or is incorrect&quot;,&quot;address&quot;:&quot;lifx_123&quot;}}} */ command(data, command) { isy.handleRequest(this.profileNum, data, command, true, (result) =&gt; { if (! result ) { return } if (result.statusCode === 404 || result.statusCode === 400) { let reason = `${data.address} or ${data.command} does not exist or is incorrect` this.sendResult(command, result, false, reason, {address: data.address}) logger.error(`${this.logPrefix} ${reason}`) } else if (result.statusCode === 200){ let reason = `${data.address} ${data.command} sent sucessfully with ${data.value}` this.sendResult(command, result, true, reason, {address: data.address}) logger.info(`${this.logPrefix} ${reason}`) NodeServerModel.sendUpdate() } }) }, /** * Instance Method for NodeServer to handle 'restcall' * @function restcall * @alias NodeServerModel.restcall * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;api&quot;:&quot;nodes/n001_d073d51327cc&quot;,&quot;seq&quot;:10068,&quot;timeout&quot;:null} * @param {string} command - The command received: 'restcall' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;nodeInfo&quot;:{&quot;node&quot;:{&quot;flag&quot;:&quot;0&quot;,&quot;nodeDefId&quot;:&quot;lifxcolor&quot;,&quot;address&quot;:&quot;n001_d073d51327cc&quot;,&quot;name&quot;:&quot;LIFX Lamp&quot;,&quot;family&quot;:{&quot;instance&quot;:&quot;1&quot;,&quot;$t&quot;:&quot;10&quot;},&quot;parent&quot;:{&quot;type&quot;:&quot;1&quot;,&quot;$t&quot;:&quot;n001_lifxcontrol&quot;},&quot;type&quot;:&quot;1.1.0.0&quot;,&quot;enabled&quot;:&quot;true&quot;,&quot;deviceClass&quot;:&quot;0&quot;,&quot;wattage&quot;:&quot;0&quot;,&quot;dcPeriod&quot;:&quot;0&quot;,&quot;startDelay&quot;:&quot;0&quot;,&quot;endDelay&quot;:&quot;0&quot;,&quot;pnode&quot;:&quot;n001_lifxcontrol&quot;,&quot;ELK_ID&quot;:&quot;A07&quot;},&quot;properties&quot;:{}}},&quot;statusCode&quot;:200,&quot;seq&quot;:10068,&quot;elapsed&quot;:&quot;29.861932ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;restcall&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;nodes/n001_d073d51327cc executed sucessfully&quot;,&quot;api&quot;:&quot;nodes/n001_d073d51327cc&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;404&quot;}},&quot;statusCode&quot;:404,&quot;seq&quot;:10068,&quot;elapsed&quot;:&quot;15.433125ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;restcall&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;ISY Returned 404 for nodes/n001_d073d51327c&quot;,&quot;api&quot;:&quot;nodes/n001_d073d51327c&quot;}}} */ restcall(data, command) { isy.handleRequest(this.profileNum, data, command, true, (result) =&gt; { if (! result ) { return } if (result.statusCode === 404) { let reason = `ISY Returned 404 for ${data.api}` this.sendResult(command, result, false, reason, {api: data.api}) logger.error(`${this.logPrefix} ${reason}`) } else if (result.statusCode === 200){ let reason = `${data.api} executed sucessfully` this.sendResult(command, result, true, reason, {api: data.api}) logger.info(`${this.logPrefix} ${reason}`) } }) }, /** * Instance Method for NodeServer to handle 'addnode' * @function addnode * @alias NodeServerModel.addnode * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;nodes&quot;: [{&quot;address&quot;: &quot;lifx_1236&quot;,&quot;name&quot;: &quot;LIFX_Lamp2&quot;,&quot;node_def_id&quot;: &quot;lifxcolor&quot;,&quot;primary&quot;: &quot;lifx_1234&quot;,&quot;drivers&quot;: [{&quot;driver&quot;: &quot;ST&quot;,&quot;value&quot;: &quot;123.3&quot;,&quot;uom&quot;: 20},{&quot;driver&quot;: &quot;GV5&quot;,&quot;value&quot;: &quot;10&quot;,&quot;uom&quot;: 23}]}], &quot;seq&quot;: 1000} * @param {string} command - The command received: 'addnode' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:1000,&quot;elapsed&quot;:&quot;100.425214ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;node lifx_1236 added successfully.&quot;,&quot;address&quot;:&quot;lifx_1236&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;25.251796ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1235 already exists on ISY&quot;,&quot;address&quot;:&quot;lifx_1235&quot;}}} */ addnode(data, command) { if (!Array.isArray(data.nodes)) return logger.error(`${this.logPrefix} - nodes must be an array.`) let primaryNodes = [] for (i in data.nodes) { if (data.nodes[i].address === data.nodes[i].primary) { primaryNodes.push(data.nodes.splice(i, 1)[0]) } } async.each(primaryNodes, (node, callback) =&gt; { this.doNodeAdd(node, command, data, (err) =&gt; { if (err) { callback(err) } else { callback() } }) }, (err) =&gt; { if (err) {logger.error(`${this.logPrefix} Error adding primary node: ${err}`)} async.each(data.nodes, (node, callback) =&gt; { this.doNodeAdd(node, command, data, (err) =&gt; { if (err) { callback(err) } else { callback() } }) }, (err) =&gt; { if (err) { logger.error(`${this.logPrefix}: ${err}`) } else { logger.info(`${this.logPrefix} completed adding node(s).`) NodeServerModel.sendUpdate() this.config() } }) }) }, doNodeAdd(node, command, data, finishcb){ if (!Array.isArray(node.drivers)) { let reason = `${node.address} drivers must be an array.` this.sendResult(command, results, false, reason, {address: node.address}) return finishcb(reason) } async.waterfall([ function (callback){ NodeServerModel.count({profileNum: this.profileNum, 'nodes.address': node.address}, (err, result) =&gt; { if (err) { return callback(err) } else { return callback(null, result) } }) }.bind(this), function (result, callback) { isy.handleRequest(this.profileNum, {api: 'nodes/' + isy.addNodePrefix(this.profileNum, node.address), seq: data.seq ? data.seq : false}, 'restcall', false, (results) =&gt; { if (results.statusCode !== 404) { let reason = `${node.address} already exists on ISY` this.sendResult(command, results, false, reason, {address: node.address}) return callback(reason) } else if (result) { logger.info(`${this.logPrefix} ${node.address} already exists in ${this.name} but does not exist on the ISY. Removing local copy and overwriting.`) for (i in this.nodes) { if (this.nodes[i].address === node.address) { this.nodes[i].remove(this.save((err) =&gt; { if (err) return callback(err) return callback() })) } } } else { return callback() } }) }.bind(this), function(callback) { let newNode = { address: node.address, name: node.name, node_def_id: node.node_def_id, primary: node.primary, drivers: node.drivers, seq: data.seq ? data.seq : false } let primaryFound = false if (node.address === node.primary) { newNode.isprimary = true primaryFound = true } for (i in this.nodes) { if (this.nodes[i].address === node.primary) { if (!(this.nodes[i].primary === this.nodes[i].address)) { let reason = `${node.primary} is not a primary. Only single layer nesting allowed.` this.sendResult(command, {profileNum: this.profileNum}, false, reason, {address: node.address}) return callback(reason) } else { this.nodes[i].isprimary = true primaryFound = true } } } if (!primaryFound) { let reason = `Primary node ${node.primary} was not found in nodes.` this.sendResult(command, {}, false, reason, {address: node.address}) return callback(reason) } isy.handleRequest(this.profileNum, newNode, command, false, (result) =&gt; { if (result.statusCode == 400) { let reason = `${newNode.address} already exists.` this.sendResult(command, result, false, reason, {address: node.address}) return callback(reason) } else if (result.statusCode == 200) { newNode.added = true this.nodes.push(newNode) this.save((err) =&gt; { if (err) return callback(err) let reason = `node ${newNode.address} added successfully.` this.sendResult(command, result, true, reason, {address: newNode.address}) logger.info(`${this.logPrefix} ${reason}`) return callback() }) } else { return callback() } }) }.bind(this) ], (err) =&gt; { if (err) { if (finishcb) { return finishcb(err) } else { return } } else { if (finishcb) { return finishcb() } else { return } } }) }, /** * Instance Method for NodeServer to handle 'removenode' * @function removenode * @alias NodeServerModel.removenode * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;node&quot;: &quot;1&quot;, &quot;removenode&quot;: {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;seq&quot;: 1004}} * @param {string} command - The command received: 'removenode' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;true&quot;,&quot;status&quot;:&quot;200&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;0&quot;}}},&quot;statusCode&quot;:200,&quot;seq&quot;:1004,&quot;elapsed&quot;:&quot;99.309321ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;removenode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;lifx_1235 removed successfully&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;403&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;5106&quot;}}},&quot;statusCode&quot;:403,&quot;seq&quot;:1004,&quot;elapsed&quot;:&quot;17.747168ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;removenode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;Could not remove lifx_1234. It is the primary for another node.&quot;}}} */ removenode(data, command, callback = null) { isy.handleRequest(this.profileNum, data, command, true, (result) =&gt; { if (! result ) { return } let success = false let reason = null let message = null if (result.statusCode === 200) { for (i in this.nodes) { if (this.nodes[i].address === data.address) { this.nodes[i].remove((err) =&gt; { if (err) { if (callback) return callback(err) else return logger.error(`${this.logPrefix} dberror on removenode`) } else { success = true message = `${data.address} removed successfully` this.save(() =&gt; { logger.info(`${this.logPrefix} node ${message}`) NodeServerModel.sendUpdate() }) this.sendResult(command, result, success, message) } }) } } } else if (result.statusCode === 403) { if (result.isyresponse.RestResponse.reason.code === &quot;5106&quot;) { reason = `Could not remove ${data.address}. It is the primary for another node.` logger.error(`${this.logPrefix} ${reason}`) this.sendResult(command, result, success, reason) } else if (result.isyresponse.RestResponse.reason.code === &quot;5003&quot;) { reason = `Could not remove ${data.address}. It doesn't exist in ISY. Will remove from DB if it exists.` logger.info(`${this.logPrefix} ${reason}`) for (i in this.nodes) { if (this.nodes[i].address === data.address) { this.nodes[i].remove((err) =&gt; { if (err) { if (callback) return callback(err) else return logger.error(`${this.logPrefix} dberror on removenode`) } else { success = true message = `${data.address} removed successfully` this.save(() =&gt; { logger.info(`${this.logPrefix} node ${message}`) NodeServerModel.sendUpdate() }) this.sendResult(command, result, success, message) } }) } } } else { reason = `Could not remove ${data.address}. ISY sent 403.` logger.error(`${this.logPrefix} ${reason}`) this.sendResult(command, result, success, reason) } } if (callback) return callback() }) }, /** * Instance Method to Query for Nodes for this NodeServer from ISY * This happens at Polyglot Startup to Sync the ISY and Polyglot Database * @function getNodesFromISY * @alias NodeServerModel.getNodesFromISY * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {errOnlyCallback} callback - Callback when complete with only parameter being an error if there was one. */ getNodesFromISY(callback) { isy.handleRequest(this.profileNum, {api: 'profiles/ns/' + this.profileNum + '/connection'}, 'restcall', true, (results) =&gt; { if (!results) { if (callback) { return callback('No ISY Response') } else return } try { if (results.isyresponse.connections.connection &amp;&amp; results.statusCode === 200) { if (this.profileNum === results.isyresponse.connections.connection.profile) { logger.info(`${this.logPrefix} - NodeServer found on ISY with the name ${results.isyresponse.connections.connection.name}. Checking for Nodes...`) async.each(this.nodes, (node, asyncCb) =&gt; { if (!node.isprimary) { return asyncCb() } isy.handleRequest(this.profileNum, {api: 'nodes/' + isy.addNodePrefix(this.profileNum, node.address)}, 'restcall', true, (results) =&gt; { if (results.statusCode === 404) { logger.info(`${this.logPrefix} ${node.address} doesn't exist in ISY. Adding...`) this.doNodeAdd(node, 'addnode', (err) =&gt; { if (err) { return asyncCb(err) } else { return asyncCb() } }) } else { logger.info(`${this.logPrefix} ${node.address} already exists in ISY. Skipping...`) return asyncCb() } }) }, (err) =&gt; { if (err) { logger.error(`${this.logPrefix} Error adding node: ${err}`) if (callback) callback(err) } else { async.each(this.nodes, (node, asyncCb) =&gt; { if (node.isprimary) { return asyncCb() } isy.handleRequest(this.profileNum, {api: 'nodes/' + isy.addNodePrefix(this.profileNum, node.address)}, 'restcall', true, (results) =&gt; { if (results.statusCode === 404) { logger.info(`${this.logPrefix} ${node.address} doesn't exist in ISY. Adding...`) this.doNodeAdd(node, 'addnode', (err) =&gt; { if (err) { return asyncCb(err) } else { return asyncCb() } }) } else { logger.info(`${this.logPrefix} ${node.address} already exists in ISY. Skipping...`) return asyncCb() } }) }, (err) =&gt; { if (err) { logger.error(`${this.logPrefix} Error adding node: ${err}`) if (callback) callback(err) } else { logger.info(`${this.logPrefix} Completed ReSync with ISY.`) if (callback) callback() } }) } }) } } } catch (err) { if (callback) return callback(err) else return err } }) }, /** * Instance Method to install this NodeServer to ISY automatically. This kicks off immediately after NodeServer is added to Polyglot via the frontend. * @function installNodeServer * @alias NodeServerModel.installNodeServer * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {responseCallback} callback - (err, response) Callback when complete with error if present, or response if no error. */ installNodeServer(callback) { logger.info(`${this.logPrefix} Attempting to install ${this.name} NodeServer into ISY.`) isy.handleRequest(this.profileNum, {api: 'profiles/ns/' + this.profileNum + '/connection'}, 'restcall', true, (results) =&gt; { if (!results.isyresponse.connections.connection &amp;&amp; results.statusCode === 200) { let args = { ip: config.settings.ipAddress, baseurl: '/ns/' + this.profileNum, name: this.name, nsuser: 'polyglot', nspwd: 'gTmZznSGe9Es6FTJ', isyusernum: 0, port: config.settings.listenPort, timeout: 0, ssl: false, enabled: true } isy.handleRequest(this.profileNum, {api: 'profiles/ns/' + this.profileNum + '/connection/set/network', args: args}, 'restcall', true, (results) =&gt; { if (results.statusCode !== 200) { let message = `Failed to install NodeServer. ISY responded with other than 200.` callback(message) } else { this.installprofile(null, null, (err) =&gt; { if (err) { callback(err) } else { let message = `Installed into ISY sucessfully. Profile.zip installed. Rebooting ISY now.` logger.info(`${this.logPrefix} ${message}`) //fs.closeSync(fs.openSync(`${this.homeDir}.installed`, 'w')); callback(null, message) } }) } }) } else if (results.isyresponse.connections.connection &amp;&amp; results.statusCode === 200){ let message = 'That Profile already exists on the ISY.' logger.error(`${this.logPrefix} ${message}`) callback(message) } else { let message = 'ISY sent a bad status code or did not respond. Check your settings.' logger.error(`${this.logPrefix} ${message}`) callback(message) } }) }, installprofile (data, command, cb = function(){}) { const JSZip = require('jszip') var profile = `${this.homeDir}profile.zip` var importTypes = ['nodedef', 'editor', 'nls'] fs.readFile(profile, (err, data) =&gt; { if (err) return logger.debug(err) JSZip.loadAsync(data).then((zip) =&gt; { async.each(importTypes, (type, cb1) =&gt; { zip.folder(type).forEach((path, file) =&gt; { file.async('text').then((data) =&gt; { isy.profileUpload(type, `${type}/${path}`, data, this.profileNum, () =&gt; { cb1() }) }) }) }, (err) =&gt; { if (err) if (cb) { return cb(err) } else { return } setTimeout(() =&gt; { isy.reboot() }, 2000) if (cb) { return cb(err) } else { return } }) }) }) }, /** * Instance Method to delete this NodeServer from ISY automatically. This kicks off immediately after NodeServer is deleted via the frontend. * @function deleteNodeServer * @alias NodeServerModel.deleteNodeServer * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {responseCallback} callback - (err, response) Callback when complete with error if present, or response if no error. */ deleteNodeServer(callback) { logger.info(`${this.logPrefix} attempting to delete NodeServer ${this.name}`) if (this.type === 'local') { child.stopChildNodeServer(config.nodeServers[this.profileNum]) } logger.info(`${this.logPrefix} deleting ${this.name}'s nodes from ISY.`) if (this.type === 'local') { //fs.unlinkSync(`${this.homeDir}.installed`) var index = config.installedNSTypes.indexOf(this.name) if (index &gt; -1) { config.installedNSTypes.splice(index, 1) } } async.each(this.nodes, (node, callback) =&gt; { if (node){ if (node.isprimary) return callback() this.removenode(node, 'removenode', (err, result) =&gt; { if (err) return callback(err) else { callback() } }) } else { callback() } }, (err) =&gt; { if (err) return callback(err) else { async.each(this.nodes, (node, callback) =&gt; { if (node){ this.removenode(node, 'removenode', (err, result) =&gt; { if (err) return callback(err) else { callback() } }) } else { callback() } }, (err) =&gt; { if (err) return callback(err) isy.handleRequest(this.profileNum, {api: 'profiles/ns/' + this.profileNum + '/connection/remove'}, 'restcall', true, (result) =&gt; { if (! result ) { return } if (result.statusCode === 200) { let message = `${this.logPrefix} ` mqtt.publish('udi/polyglot/connections/' + this.profileNum, null, {retain: true}) this.remove((err) =&gt; { if (err) return callback(err) message += 'Succesfully removed NodeServer. Rebooting ISY now.' mqtt.delSubscription(this.profileNum) delete config.nodeServers[this.profileNum] isy.reboot() logger.info(`${message}`) callback(null, message) }) } else { let message = `${this.logPrefix} ISY returned something other than 200, this usually means the NodeServer is out of range. Deleting from DB... ` this.remove((err) =&gt; { if (err) return callback(err) message += 'Success' logger.info(`${message}`) callback(null, message) }) } }) }) } }) }, /** * Instance Method to Send a result message to the NodeServer via MQTT * @function sendResult * @alias NodeServerModel.sendResult * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {string} command - Command NodeServer is sending a result for. * @param {Object} result - The result object data. * @param {boolean} success - True/false * @param {string} reason - Sucess reason * @param {Object} extra - Extra Parameters to send to the NodeServer if needed. */ sendResult(command, result, success, reason, extra = null) { result[command] = { success: success, reason: reason } if (extra) { result[command] = Object.assign(result[command], extra) } mqtt.makeResponse(this.profileNum, 'result', result) }, /** * Instance Method to handle 'request' from NodeServer * @function request * @alias NodeServerModel.request * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {Object} data - {&quot;node&quot;: &quot;8&quot;, &quot;request&quot;: {&quot;requestId&quot;: &quot;3949&quot;, &quot;success&quot;: true}} * @param {string} command - This command 'request'. * @returns {Object} result - Responds only on failure. Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:404,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;8.202375ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;request&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;ISY Returned 404 for request ID: 22&quot;,&quot;id&quot;:&quot;22&quot;}}} */ request(data, command) { isy.handleRequest(this.profileNum, data, command, false, (result) =&gt; { if (! result ) { return } if (result.statusCode === 404 || result.statusCode === 400) { let reason = `ISY Returned 404 for request ID: ${data.requestId}` this.sendResult(command, result, false, reason, {id: data.requestId}) logger.error(`${this.logPrefix} ${reason}`) } else if (result.statusCode === 200){ let reason = `${data.requestId} reported sucessfully as ${data.success}` this.sendResult(command, result, true, reason, {id: data.requestId}) logger.info(`${this.logPrefix} ${reason}`) } }) }, /** * Instance Method to handle 'config' from NodeServer * @function config * @alias NodeServerModel.config * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {Object} data - {&quot;node&quot;: &quot;1&quot;, &quot;config&quot;: null, &quot;seq&quot;: 1000} * @param {string} command - This command 'config'. * @returns {Object} response - Returns existing NodeServer configuration: {&quot;config&quot;:{&quot;name&quot;:&quot;LiFX&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;nodes&quot;:[{&quot;address&quot;:&quot;lifx_1234&quot;,&quot;name&quot;:&quot;LIFX_Lamp2&quot;,&quot;drivers&quot;:[{&quot;driver&quot;:&quot;ST&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;123.3&quot;},{&quot;driver&quot;:&quot;GV5&quot;,&quot;uom&quot;:23,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:true,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496550684087&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true},{&quot;address&quot;:&quot;lifx_1235&quot;,&quot;name&quot;:&quot;TouchMe&quot;,&quot;drivers&quot;:[{&quot;driver&quot;:&quot;ST&quot;,&quot;uom&quot;:56,&quot;value&quot;:&quot;593.3&quot;},{&quot;driver&quot;:&quot;GV1&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:false,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496552508813&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true}],&quot;token&quot;:null,&quot;encryptPayload&quot;:false,&quot;time_added&quot;:&quot;1496545371618&quot;,&quot;isConnected&quot;:false}} */ config(data = null, command = null) { // Hack to deepcopy this.nodes var parseConfig = this.toJSON() parseConfig.isyVersion = config.settings.isyVersion parseConfig._id = undefined parseConfig.nodes.forEach((node) =&gt; { node._id = undefined node.drivers.forEach((driver) =&gt; { driver._id = undefined }) }) mqtt.makeResponse(this.profileNum, 'config', parseConfig) }, /** * Instance Method to handle 'connected' from NodeServer * @function connected * @alias NodeServerModel.connected * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {Object} data - {&quot;node&quot;: &quot;1&quot;, &quot;connected&quot;: true} or {&quot;node&quot;: &quot;1&quot;, &quot;connected&quot;: false} * @param {string} command - This command 'connected'. */ connected(data, command) { this.isConnected = data this.save(() =&gt; { logger.info(`${this.logPrefix} NodeServer ${(data ? 'Connected.' : 'Disconnected.')}`) this.config(data, command) NodeServerModel.sendUpdate() }) }, /** * Instance Method for NodeServer to handle 'customparams' * @function customparams * @alias NodeServerModel.customparams * @memberof module:models/nodeserver~NodeServerModel * @instance * @param {object} data - JSON parsed from incoming message e.g. {&quot;nodes&quot;: [{&quot;address&quot;: &quot;lifx_1236&quot;,&quot;name&quot;: &quot;LIFX_Lamp2&quot;,&quot;node_def_id&quot;: &quot;lifxcolor&quot;,&quot;primary&quot;: &quot;lifx_1234&quot;,&quot;drivers&quot;: [{&quot;driver&quot;: &quot;ST&quot;,&quot;value&quot;: &quot;123.3&quot;,&quot;uom&quot;: 20},{&quot;driver&quot;: &quot;GV5&quot;,&quot;value&quot;: &quot;10&quot;,&quot;uom&quot;: 23}]}], &quot;seq&quot;: 1000} * @param {string} command - The command received: 'addnode' * @returns {object} response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:1000,&quot;elapsed&quot;:&quot;100.425214ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;node lifx_1236 added successfully.&quot;,&quot;address&quot;:&quot;lifx_1236&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;25.251796ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1235 already exists on ISY&quot;,&quot;address&quot;:&quot;lifx_1235&quot;}}} */ customparams(data, command, callback) { logger.info(`NS: Recieved updated Custom Parameters for ${this.name}. Updating database.`) delete data.profileNum //logger.debug(data) this.customParams = data this.save() if (callback) { return callback(null, 'Custom Parameters saved to database sucessfully.') } }, start(data, command) { if (!(child.nodeProcesses[this.profileNum])) { child.runChildNodeServer(config.nodeServers[this.profileNum]) } else { return } }, stop(data, command) { if (child.nodeProcesses[this.profileNum]) { child.stopChildNodeServer(config.nodeServers[this.profileNum]) } else { return } }, restart(data, command) { if (child.nodeProcesses[this.profileNum]) { child.stopChildNodeServer(config.nodeServers[this.profileNum]) } setTimeout(() =&gt; { child.runChildNodeServer(config.nodeServers[this.profileNum]) }, 3000) }, notfound(data, command) { logger.info(`${this.logPrefix} command not found: ${command}`) } } NodeServerModel = mongoose.model('NodeServer', NodeServerSchema) module.exports = NodeServerModel /** @callback addnsCallback @param {string} error - An Error if returned @param {Object} response - {&quot;seq&quot;:53407,&quot;response&quot;:{&quot;success&quot;:true,&quot;msg&quot;:&quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;,&quot;nodeserver&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;}}} */ /** @callback findArrayCallback @param {string} error - An Error if encountered @param {Object} documents - Array of documents returned by Mongoose Find */ /** @callback findCallback @param {string} error - An Error if encountered @param {Object} document - Document returned by Mongoose FindOne */ /** @callback errOnlyCallback @param {string} error - An Error if encountered */ /** @callback responseCallback @param {string} error - An Error if encountered @param {Object} response - Object response returned to callback if no error occurred. */ × Search results Close "},"models_user.js.html":{"id":"models_user.js.html","title":"Source: models/user.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: models/user.js const mongoose = require('mongoose') const bcrypt = require('bcryptjs') //const config = require('../config/config') var logger = require('../modules/logger') /** * User Model and Class. * @module models/user * @version 2.0 */ /** * MongoDB - UserSchema for creating a new User Database Object * @class UserModel * @param {string} username - Username of new User * @param {string} password - Password of new User */ const UserSchema = mongoose.Schema({ username: { type: String, default: 'admin', required: true }, password: { type: String, default: '$2a$04$YITtr92Y0l4zYe2mVE4Jvey8Ao/9dK.vPu7Ww5yQVWd6bxXoFKVyC', // 'admin' required: true } }) UserSchema.statics = { /** * MongoDB gets user from database by ID. * @method * @alias UserModel.sendUpdate * @memberof module:models/user * @param {string} id - ID to search for. * @param {findCallback} callback - Callback Passed into the Mongoose find method. */ getUserById (id, callback){ UserModel.findById(id, callback) }, /** * MongoDB gets user from database by Username. * @method * @alias UserModel.getUserByUsername * @memberof module:models/user * @param {string} username - Username to search for. * @param {findCallback} callback - Callback Passed into the Mongoose find method. */ getUserByUsername (username, callback){ const query = {username: username} UserModel.findOne(query, callback) }, /** * Adduser salts and hashes the password using bcrypt before saving it to the database. * &lt;TODO&gt; This has become problematic on older machines such as the Raspberry Pi 1. * It is extremely slow to do the comparison. Gotta find a better way. Maybe less salts. * @method * @alias UserModel.addUser * @memberof module:models/user * @param {Object} newUser - new instance of UserModel * @param {saveCallback} callback - Callback Passed into the Mongoose find method. */ addUser (newUser, callback){ bcrypt.genSalt(2, (err, salt) =&gt; { bcrypt.hash(newUser.password, salt, (err, hash) =&gt; { if(err) throw err newUser.password = hash newUser.save(callback) logger.info(`User: Created new user ${newUser.username}`) }) }) }, /** * Compare salts and hashes with the password using bcrypt. * &lt;TODO&gt; This has become problematic on older machines such as the Raspberry Pi 1. * It is extremely slow to do the comparison. Gotta find a better way. Maybe less salts. * @method * @alias UserModel.addUser * @memberof module:models/user * @param {string} password - Password attempting to authenticate with. * @param {compareCallback} callback - Callback Passed into the Mongoose find method. */ comparePassword (candidatePassword, hash, callback) { bcrypt.compare(candidatePassword, hash, (err, isMatch) =&gt; { if(err) throw err callback(null, isMatch) }) }, verifyDefaultUser (callback) { UserModel.find({}, null, null, (err, users) =&gt; { if (users.length &gt; 0) { if (callback) return callback(err) } else { const newUser = new UserModel() newUser.save() logger.info('Users: No users found in database. Adding default user.') if (callback) return callback(err) } }) } } UserModel = mongoose.model('User', UserSchema) module.exports = UserModel /** @callback findCallback @param {string} error - An Error if encountered @param {Object} document - Document returned by Mongoose FindOne */ /** @callback saveCallback @param {string} error - An Error if encountered @param {Object} document - Document returned if sucessfully saved by Mongoose save method */ /** @callback compareCallback @param {string} error - An Error if encountered @param {boolean} isMatch - True/False is password hashed successfully with bcrypt. */ × Search results Close "},"modules_db.js.html":{"id":"modules_db.js.html","title":"Source: modules/db.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/db.js const mongoose = require('mongoose') const config = require('../config/config') const SettingsModel = require('../models/settings') const UserModel = require('../models/user') const isy = require('../modules/isy') const logger = require('./logger') mongoose.Promise = global.Promise /** * Database Module * @module modules/db * @version 2.0 */ module.exports = { /** MongoDB Connection var */ Server: null, /** * MongoDB Start Service and Connect via .env MONGO_URI provided. * @method * @param {startCallback} callback - Callback when connected and all NodeServers were retrieved. */ startService(callback) { if (!this.Server) { // Connect to database opts = { useMongoClient: true, reconnectTries: Number.MAX_VALUE, reconnectInterval: 5000, promiseLibrary: global.Promise } var mongoURI = process.env.MONGO_URI || 'mongodb://localhost:27017/' this.Server = mongoose.connect(mongoURI + 'polyglot', opts) // On Connection mongoose.connection.on('connected', () =&gt; { logger.info('MongoDB: Connected') config.dbConnected = true UserModel.verifyDefaultUser() SettingsModel.loadSettings(() =&gt; { isy.getVersion() if (callback) { return callback()} }) }) mongoose.connection.on('disconnected', () =&gt; { config.dbConnected = false logger.error('MongoDB: Disconnected from database. Retrying every 5 seconds.') }) // On Error mongoose.connection.on('error', (err) =&gt; { logger.error('MongoDB: ' + err) config.dbConnected = false this.Server.disconnect() }) } }, /** * MongoDB Stop Service run on program shutdown. * @method * @param {stopCallback} callback - Callback when shutdown or error. */ stopService(callback) { if (this.Server) { this.Server.disconnect((err) =&gt; { this.Server = null logger.info('MongoDB: Disconnected') if(callback) { callback() } }) } else { if(callback) { callback() } } } } /** @callback startCallback @param {string} error - An Error if encountered @param {Object} documents - Documents returned if sucessfully connected and retrieved existing NodeServer documents. */ /** @callback stopCallback @param {string} error - An Error if encountered */ × Search results Close "},"modules_encryption.js.html":{"id":"modules_encryption.js.html","title":"Source: modules/encryption.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/encryption.js // Nodejs encryption with CTR const crypto = require('crypto'); const algorithm = 'aes-256-ctr'; const encoding = ',2YE6=#r(z5?Y4=a'; /** * The encryption module to encrypt communications between NodeServers and Polyglot * this is tested, however it is not enabled as of release 2.0 * @module modules/encryption * @version 2.0 */ /** * encryptText * @param {string} text - Text to encrypt * @returns {string} Encrypted Text */ module.exports.encryptText = function(text) { var cipher = crypto.createCipher(algorithm, encoding) var crypted = cipher.update(text,'utf8','hex') crypted += cipher.final('hex'); return crypted; } /** * decryptText * @param {string} text - Text to decrypt * @returns {string} Decrypted Text */ module.exports.decryptText = function(text) { var decipher = crypto.createDecipher(algorithm, encoding) var dec = decipher.update(text, 'hex','utf8') dec += decipher.final('utf8'); return dec; } × Search results Close "},"modules_helpers.js.html":{"id":"modules_helpers.js.html","title":"Source: modules/helpers.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/helpers.js const logger = require('../modules/logger') const config = require('../config/config') const SettingsModel = require('../models/settings') const NodeServerModel = require('../models/nodeserver') const db = require('../modules/db') const mqttc = require('../modules/mqttc') const mqtts = require('../modules/mqtts') const child = require('../modules/children') const web = require('../modules/web') const async = require('async') const fs = require('fs') const path = require('path') /** * Generic Helpers Module that has a couple of various methods that didn't fit elsewhere. * @module modules/helpers * @version 2.0 */ module.exports = { /* checkServices() { if (!mqtt.Client) { mqtt.startService(() =&gt; { this.resyncNodesToISY() }) } else { mqtt.stopService() } }, */ /** * resyncNodesToISY wraps a couple of database/ISY checks to make sure the ISY and Local MongoDB are in sync. * @param {function} callback - Simple callback function that returns on error or when function is complete. */ resyncNodesToISY(callback=null) { logger.info(`ReSyncing NodeServers with ISY...`) async.each(config.nodeServers, (nodeServer, callback) =&gt; { if (!nodeServer) { return callback() } nodeServer.getNodesFromISY(() =&gt; { if (callback) return callback() }) }, (err) =&gt; { if (err) { logger.error(`ReSync NodeServers ERROR: ${err}`) if (callback) return callback(err) } else { SettingsModel.sendUpdate() NodeServerModel.sendUpdate() if (callback) return callback() } }) }, /** * restartServices is an external function to stop then restart the MQTT service and re-initiate a NodeServer Resync */ restartServices() { mqttc.stopService(() =&gt; { mqtts.stopService(() =&gt; { setTimeout(() =&gt; { mqtts.startService(() =&gt; { mqttc.startService(() =&gt; { this.resyncNodesToISY() }) }) },1000) }) }) }, /** * shutdown is the program stop function to terminate the application gracefully. */ shutdown() { async.series([ this.killChildren(), this.saveNodeServers(), //web.stopService(), mqttc.stopService(), mqtts.stopService(), //db.stopService(), setTimeout(process.exit(0),500) ]) }, /** * saveNodeServers will cycle through all the NodeServers and save the current state to MongoDB. This occurrs automatically before shutdown. */ saveNodeServers(callback) { config.nodeServers.forEach((nodeServer) =&gt; { logger.debug(`Saving NodeServer ${nodeServer.name} to database.`) nodeServer.save() if (callback) { return callback() } }) }, killChildren(callback) { child.nodeProcesses.forEach((np, i) =&gt; { if (np) { //config.nodeServers[i] child.stopChildNodeServer(config.nodeServers[i]) } }) }, /* * Sweet little function wrapper I found to allow me to push * functions into arrays for easy reacall with params. */ wrapFunction(fn, context, params) { return function() { fn.apply(context, params); } }, /* * Return directories in a given path, includes symlinks */ dirs(p) { return fs.readdirSync(p).filter(f =&gt; fs.statSync(path.join(p, f)).isDirectory()) } } × Search results Close "},"modules_isy.js.html":{"id":"modules_isy.js.html","title":"Source: modules/isy.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/isy.js const logger = require('./logger') const config = require('../config/config') require('http').globalAgent.maxSockets = Infinity const request = require('request') const encrypt = require('./encryption') const xmlparser = require('xml2json-light') const querystring = require('querystring') const mqtt = require('./mqttc') /** * ISY API Module for REST calls to the ISY Interfaces * @module modules/isy * @version 2.0 */ module.exports = { /** * Automactially adds the ISY Node Prefix onto the address before querying the API. * @method * @param {number} profileNum - The NodeServer profileNum. * @param {string} nod - The NodeServer address id */ addNodePrefix(profileNum, nid) { return `n${('00' + profileNum).slice(-3)}_${nid}`.slice(0, 20) }, /** * Creates the API URL to query ISY * /rest/{api}/?{path_args} * @method * @param {string} api - The ISY API path to query * @param {object} path_args - Dictionary of path arguments appended to the URL. */ makeApiUrl(api, path_args = null) { url = `${config.settings.isyHttps === 'true' ? 'https://' : 'http://'}${config.settings.isyHost}:${config.settings.isyPort}/rest/${api}/` if (path_args) { url += '?' + querystring.stringify(path_args) } //url = encodeURI(url) return url }, /** * Creates the Node URL to query ISY * /rest/ns/{profileNum}/{path}/?{path_args} * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} path - The ISY path to query * @param {object} path_args - Dictionary of path arguments appended to the URL. */ makeNodeUrl(profileNum, path, path_args) { url = `${config.settings.isyHttps === 'true' ? 'https://' : 'http://'}${config.settings.isyHost}:${config.settings.isyPort}/rest/ns/${profileNum}/${path.join('/')}` if (path_args) { url += '?' + querystring.stringify(path_args).trim() } //url = encodeURI(url) return url }, /** * Performs the actual query to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} url - The URL created by makeNodeUrl or makeApiUrl * @param {number} seq - Sequence number to verify response on specific call * @param {boolean} getText - Get full response text from ISY and package it in the response. True/False * @param {function} callback - Simple (err, response) callback with the result success or fail. */ getIsy(profileNum, url, seq, getText, callback){ var options = { &quot;url&quot;: url, } var hrstart = process.hrtime() request.get(options, (err, res, body) =&gt; { if (err) return callback(err) var text='' //var xmlOptions = {object: true} logger.debug(`ISY: ${res.statusCode} - ${url}`) if (getText) { text = xmlparser.xml2json(body) } result = { isyresponse: text, statusCode: res.statusCode, seq: seq, elapsed: process.hrtime(hrstart)[1]/1000000 + 'ms', profileNum: profileNum } return callback(null, result) }).auth(config.settings.isyUsername, encrypt.decryptText(config.settings.isyPassword)) }, /** * Handles the Request from Polyglot calls TO the ISY and formats them appropriately based on type. * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} command - Command received to query to the ISY * @param {boolean} getText - Get full response text from ISY and package it in the response. True/False. Default is False * @param {function} callback - Simple (response) callback with the result success or fail. */ handleRequest(profileNum, data, command, gettext = false, callback){ var url = (this[command] || this['notfound']).call(this, profileNum, data, command) if (url){ this.getIsy(profileNum, url, data.seq ? data.seq : false, gettext, (err, result)=&gt; { if (err) return logger.error(`ISY: ${err}`) if (callback) return callback(result) }) } else { logger.error(`ISY: handleRequest - ${command} did not return a valid URL.`) if (callback) { return callback() } } }, /** * Handles the status calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ status(profileNum, data, cmd) { var url=false if (data.address) { //var url = isy.makeApiUrl(this.profileNum, 'config', {'test': true}) var address = this.addNodePrefix(profileNum, data.address) var path = ['nodes', address, 'report', 'status', data.driver, data.value, data.uom] url = this.makeNodeUrl(profileNum, path) } else { logger.error(`ISY: address not found in ${cmd} call.`) } return url }, /** * Handles the command calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ command(profileNum, data, cmd) { var url=false if (data.address) { var address = this.addNodePrefix(profileNum, data.address) var path = ['nodes', address, 'report', 'cmd', data.command] var checks = [data.value, data.uom] for (var index in checks) { if (checks[index] !== null) { path.push(checks[index]) } } var url = this.makeNodeUrl(profileNum, path) } else { logger.error(`ISY: Error address not found in ${cmd} call.`) } return url }, /** * Handles the addnode calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ addnode(profileNum, data, cmd){ var url=false if (data.address &amp;&amp; data.primary &amp;&amp; data.name &amp;&amp; data.node_def_id) { var address = this.addNodePrefix(profileNum, data.address) var primary = this.addNodePrefix(profileNum, data.primary) var path = ['nodes', address, 'add', data.node_def_id] var queryargs = { 'primary': primary, 'name': data.name } var url = this.makeNodeUrl(profileNum, path, queryargs) } else { logger.error(`ISY: Error address, primary, node_def_id, or name not found in ${cmd} call.`) } return url }, /** * Handles the removenode calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ removenode(profileNum, data, cmd){ var url=false if (data.address) { var address = this.addNodePrefix(profileNum, data.address) var path = ['nodes', address, 'remove'] var url = this.makeNodeUrl(profileNum, path) } else { logger.error(`ISY: Error address not found in ${cmd} call.`) } return url }, /** * Handles the restcall calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ restcall(profileNum, data, cmd) { var url=false if (data.api) { url = this.makeApiUrl(data.api, data.args) } else { logger.error(`ISY: api not found in ${cmd} call.`) } return url }, /** * Handles the request calls to ISY * @method * @param {number} profileNum - The NodeServer profileNum * @param {string} data - Data received for the type of query from MQTT. * @param {string} cmd - Command received to query to the ISY */ request(profileNum, data, cmd){ var url=false if (data.requestId) { var path = ['report', 'request', data.requestId, data.success ? 'success' : 'fail'] var url = this.makeNodeUrl(profileNum, path) } else { logger.error(`ISY: Error request_id or success not found in ${cmd} call.`) } return url }, /** * Handles the inital getVersion request to verify ISY connectivity * @method * @param {function} callback - Simple (err) callback if there is an error. Otherwise no parameters passed. We save the result in the config/config singleton. */ getVersion(callback) { var version = '' var data = {} data['api'] = 'config' var url = this.restcall(0, data, 'getVersion') this.getIsy(0, url, false, true, (err, result) =&gt; { try { config.settings.isyVersion = result.isyresponse.configuration.app_version config.settings.save() logger.info(`ISY: Got Version ${config.settings.isyVersion}`) } catch (e) { logger.error(`ISY: Failed to get version.`) if (callback) return callback(e) } if (callback) return callback() }) }, profileUpload(type, filename, data, profileNum, callback = function(){}) { let url = `${config.settings.isyHttps === 'true' ? 'https://' : 'http://'}${config.settings.isyHost}:${config.settings.isyPort}/rest/ns/profile/${profileNum}/upload/${filename}` let options = { headers: {'content-type': 'application/xml'}, url: url, body: data } request.post(options, (err, res, body) =&gt; { if (res.statusCode === 200) { logger.debug(`NS: Sucessfully uploaded ${filename} to ISY.`) callback() } else { logger.debug(`NS: Failed to upload ${filename} to ISY. Please upload profile.zip manually.`) callback() } }).auth(config.settings.isyUsername, encrypt.decryptText(config.settings.isyPassword)) }, reboot() { let data = `&lt;s:Envelope&gt; &lt;s:Body&gt; &lt;u:Reboot xmlns:u=&quot;urn:udi-com:service:X_Insteon_Lighting_Service:1&quot;&gt; &lt;code&gt;&lt;/code&gt; &lt;/u:Reboot&gt; &lt;/s:Body&gt; &lt;/s:Envelope&gt;` let url = `${config.settings.isyHttps === 'true' ? 'https://' : 'http://'}${config.settings.isyHost}:${config.settings.isyPort}/services` let options = { headers: {'content-type': 'application/x-www-form-urlencoded'}, url: url, body: data } request.post(options, (err, res, body) =&gt; { if (res.statusCode === 200) { logger.debug(`ISY: Reboot command sent to ISY sucessfully.`) } else { logger.debug(`ISY: Reboot command not sent to ISY sucessfully. Status Code: ${res.statusCode}`) } }).auth(config.settings.isyUsername, encrypt.decryptText(config.settings.isyPassword)) }, /** * Handles the incoming install command from ISY * Not Implemented from the ISY at the moment. (I can't get ISY to send me the command) * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restInstall(req, res) { logger.debug('Got REST Install ', req.params, req.query) }, /** * Handles the incoming status command from ISY and passes it along to the NodeServer * This handles the succesful response to ISY as well. * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restStatus(req, res) { let message = { address: req.params.nodeAddress === &quot;0&quot; ? 'all' : req.params.nodeAddress } mqtt.makeResponse(req.params.id, req.params.command, message) if (req.query.requestId) { let data = { requestId: req.query.requestId, success: true } this.handleRequest(req.params.id, data, 'request') } }, /** * Handles the addnodes command from ISY * Not implemented on the ISY side yet. * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restAddNodes(req, res) { console.log(req.params, req.query) }, /** * Handles the report command from ISY * Not implemented on the ISY side yet. * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restReport(req, res) { console.log(req.params, req.query) }, /** * Handles the 'command' command from ISY and passes it to the NodeServer to exectue a command. e.g. DON/DOF/etc. * @method * @param {object} req - Express incoming request object. * Params at req.params * Query vars at req.query * @param {object} res - Express response object. */ restCommand(req, res) { logger.debug(`Sending ${req.params.command} to ${req.params.nodeAddress}`) command = { address: req.params.nodeAddress.slice(5), cmd: req.params.command, value: req.params.value || undefined, uom: req.params.uom || undefined, query: req.query || undefined } mqtt.makeResponse(req.params.id, 'command', command) } } × Search results Close "},"modules_logger.js.html":{"id":"modules_logger.js.html","title":"Source: modules/logger.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/logger.js /* Instantiate the logger for all modules */ const os = require('os') const fs = require('fs') /** * Logger Module * @module modules/logger * @version 2.0 */ /** * Default log level is INFO. If .env parameter of NODE_ENV is set to to 'development' then we up the level to DEBUG */ var logLevel = 'info' var logDir = os.homedir() + '/.polyglot/log/' /** * Create logDir if it does not exist */ if (!fs.existsSync(logDir)) { fs.mkdirSync(logDir) } /** * Default log level is INFO. If .env parameter of NODE_ENV is set to to 'development' then we log to the console as well as the file. */ var transports = [] var winston = require('winston') require('winston-logrotate') var tsFormat = () =&gt; (new Date()).toLocaleString() if (process.env.NODE_ENV === 'development') { logLevel = 'debug' transports.push( new (winston.transports.Console)({ timestamp: tsFormat, level: logLevel, colorize: true, handleExceptions: true, humanReadableUnhandledException: true })) } transports.push( new (winston.transports.Rotate)({ file: os.homedir() + '/.polyglot/log/debug.log', timestamp: tsFormat, level: logLevel, size: '1m', keep: 10, compress: false, handleExceptions: true, humanReadableUnhandledException: true, exitOnError: true, json: false }) ) var winston = new (winston.Logger)({ transports: transports }) module.exports = winston × Search results Close "},"modules_mqttc.js.html":{"id":"modules_mqttc.js.html","title":"Source: modules/mqttc.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/mqttc.js const logger = require('./logger') const mqtt = require('mqtt') const config = require('../config/config') /** * MQTT Client Module * @module modules/mqttc * @version 2.0 */ module.exports = { /** MQTT Client var */ Client: null, /** MQTT clientId var */ clientId: null, /** * MQTT Start Service and Connect via .env MQTT_HOST and MQTT_PORT provided. * @method * @param {function} callback - Callback when connected or if already started. */ startService(callback) { if (this.Client) { if (callback) return callback() } this.clientId = 'polyglot' var options = { keepalive: 60, clean: true, clientId: this.clientId, reconnectPeriod: 5000, will: { retain: true } } var host = config.settings.mqttHost var port = config.settings.mqttPort options['will']['topic'] = 'udi/polyglot/connections/polyglot' options['will']['payload'] = new Buffer(JSON.stringify({node: this.clientId, 'connected': false})) options['rejectUnauthorized'] = false this.Client = mqtt.connect('mqtt://'+ host + ':' + port, options) this.Client.on('connect', () =&gt; { this.addSubscriptions() }) this.Client.on('message', (topic, payload) =&gt; { if (! payload ) return try { payload = JSON.parse(payload.toString()) } catch (e) { logger.error('MQTTC: Badly formatted JSON input received. ' + e) return } this.parse(topic, payload) }) this.Client.on('reconnect', () =&gt; { config.mqttConnected = false logger.info('MQTT attempting reconnection to broker...') }) this.Client.on('error', (err) =&gt; { logger.error('MQTT recieved error: ' + err.toString()) }) logger.info('MQTT Client Service: Started') if (callback) callback() }, /** * MQTT Addsubscriptions to Polyglot topics and existing NodeServer topics. * @method */ addSubscriptions() { this.Client.subscribe('udi/polyglot/connections/#', (err, granted) =&gt; { if (err) { logger.error('Error: ' + err.toString()) return } config.mqttConnected = true logger.info('MQTTC: Subscribe Successful ' + granted[0]['topic'] + &quot; QoS: &quot; + granted[0]['qos']) this.publish('udi/polyglot/connections/polyglot', {node: this.clientId, 'connected': true}, { retain: true }) }) this.Client.subscribe('udi/polyglot/frontend/settings') this.Client.subscribe('udi/polyglot/frontend/nodeservers') this.Client.subscribe('udi/polyglot/frontend/log') config.nodeServers.forEach((nodeServer) =&gt; { if (nodeServer.type === 'unmanaged') { return } this.addSubscription(nodeServer.profileNum) }) }, /** * MQTT Addsubscription to new NodeServer * @method * @param {number} profileNum - add new subscription to NodeServer with profileNum. */ addSubscription(profileNum) { this.Client.subscribe('udi/polyglot/ns/' + profileNum, (err, granted) =&gt; { if (err) { return logger.error('Error: ' + err.toString()) } if (granted[0]) { logger.info('MQTTC: Subscribe Successful ' + granted[0]['topic'] + &quot; QoS: &quot; + granted[0]['qos']) } }) this.Client.subscribe('udi/polyglot/profile/' + profileNum, (err, granted) =&gt; { if (err) { return logger.error('Error: ' + err.toString()) } if (granted[0]) { logger.info('MQTTC: Subscribe Successful ' + granted[0]['topic'] + &quot; QoS: &quot; + granted[0]['qos']) } }) }, delSubscription(profileNum) { this.Client.unsubscribe('udi/polyglot/ns/' + profileNum, (err, granted) =&gt; { if (err) { return logger.error('Error: ' + err.toString()) } logger.info(`MQTTC: Unsubscribed Successfully from NodeServer ${profileNum} /ns`) }) this.Client.unsubscribe('udi/polyglot/profile/' + profileNum, (err, granted) =&gt; { if (err) { return logger.error('Error: ' + err.toString()) } logger.info(`MQTTC: Unsubscribed Successfully from NodeServer ${profileNum} /profile`) }) }, /** * MQTT Stop Service * @method * @param {function} callback - Callback when service is and conneciton is clear. */ stopService(callback) { if(this.Client){ this.publish('udi/polyglot/connections/polyglot', {node: this.clientId, 'connected': false}, { retain: true }) logger.info('MQTT Services Stopping Gracefully.') this.Client.end(true, () =&gt; { this.Client = null if(callback) { callback() } }) } else { if(callback) { callback() } } }, /** * MQTT Make Response * @method * @param {string} topic - topic to publish to. Should be either 'connections' or the profileNum of the NodeServer * @param {string} command - Command to send, e.g 'status', etc. * @param {object} message - Dictionary object of message to send. JSON format. */ makeResponse(topic, command, message) { if (topic === 'connections' || topic === 'udi/polyglot/connections/polyglot') { topic = 'udi/polyglot/connections/polyglot' } else { topic = 'udi/polyglot/ns/' + topic } try { var response = {'node': 'polyglot'} response[command] = message } catch (e) { var response = { 'node': 'polyglot', 'data': { 'error': e } } } this.publish(topic, response) }, /** * MQTT Once MakeResponse is complete, publish the message to MQTT * @method * @param {string} topic - topic to publish to. Should be either 'connections' or the profileNum of the NodeServer * @param {object} message - Dictionary object of message to send. JSON format. * @param {object} options - Typically used for {retain: True/False} to retain the last message. [Optional] * @param {function} callback - Callback when publish is complete. [Optional] */ publish(topic, message, options, callback) { message = JSON.stringify(message) this.Client.publish(topic, message, options, callback) }, /** * MQTT Parse incoming message from MQTT * @method * @param {string} topic - topic received on. * @param {object} message - Dictionary object of message. JSON parsed into object. */ parse(topic, message) { //var parse = false if (! message) { return } if (message.hasOwnProperty('node')) { if (message.node === 'polyglot') { return } if (topic === 'udi/polyglot/frontend/settings') { require('../models/settings').updateSettings(message) return } if (topic === 'udi/polyglot/frontend/nodeservers') { require('../models/nodeserver').parseFrontend(message) return } if (topic === 'udi/polyglot/frontend/log') { require('../models/nodeserver').parseLog(message) return } //Noisy logger.debug('MQTTC: Message: ' + topic + &quot;: &quot; + JSON.stringify(message)) try { if (topic.substring(0,25) === 'udi/polyglot/connections/') { if (message.node.toString().substring(0,18) === 'polyglot_frontend-') { logger.info('MQTTC: Frontend Websockets interface ' + (message.connected ? 'Connected.' : 'Disconnected.')) } else if ((config.nodeServers[message.node]) &amp;&amp; (message.node === config.nodeServers[message.node].profileNum)) { try { config.nodeServers[message.node].checkCommand(message) } catch (e) { logger.error(`MQTT CheckCommand Error: ${e}`) } } } else if ((topic.substring(0,16) === 'udi/polyglot/ns/') &amp;&amp; ((topic.slice(-1) === message.node) || (message.node.toString().substring(0,18) === 'polyglot_frontend-'))) { if ((config.nodeServers[message.node]) &amp;&amp; (message.node === config.nodeServers[message.node].profileNum)) { try { config.nodeServers[message.node].checkCommand(message) } catch (e) { logger.error(`MQTT CheckCommand Error: ${e}`) } } } else { logger.debug('MQTTC: Did not match any parse filters. Ignoring. This usually means ' + 'the node value is incorrect. Make sure it matches an active NodeServer and you are publishing to the correct topic. ' + message) } } catch (err) { logger.error('MQTT Parse Error: ' + err) } } else { logger.error('MQTT Packet Did not have node key: ' + message) } } } × Search results Close "},"modules_mqtts.js.html":{"id":"modules_mqtts.js.html","title":"Source: modules/mqtts.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/mqtts.js const logger = require('./logger') const mosca = require('mosca') const config = require('../config/config') const os = require('os') const util = require('util') /** * MQTT Server Module * @module modules/mqtts * @version 2.0 */ module.exports = { /** MQTT Server var */ Server: null, clientDisconnectCallbacks: {}, /** * MQTT Server Start Service. * @method * @param {function} callback - Callback when connected or if already started. */ startService(callback) { if (this.Client) { if (callback) return callback() } var ascoltatore = { type: 'mongo', url: 'mongodb://localhost:27017/mqtt', pubsubCollection: 'ascoltatori', mongo: {} } const sslDir = os.homedir() + '/.polyglot/ssl/' var mongoURI = process.env.MONGO_URI || 'mongodb://localhost:27017/' var moscaSetting = { //port: config.settings.mqttPort, //host: &quot;10.0.0.75&quot;, // specify an host to bind to a single interface persistence: { factory: mosca.persistence.Mongo, url: mongoURI + 'mqtt' }, http: { port: config.settings.mqttWSPort, bundle: true, static: './' }, /* secure: { port: config.settings.mqttPort, keyPath: sslDir + 'polyglot.key', certPath: sslDir + 'polyglot.crt' }, allowNonSecure: true, */ backend: ascoltatore } var authenticate = function (client, username, password, callback) { // Keeping Authentication off for now // TODO: Implement authentication to MQTT Server // if (username == &quot;test&quot; &amp;&amp; password.toString() == &quot;test&quot;) callback(null, true) // else // callback(null, false) } var authorizePublish = function (client, topic, payload, callback) { callback(null, true) } var authorizeSubscribe = function (client, topic, callback) { callback(null, true) } this.Server = new mosca.Server(moscaSetting) this.Server.on('ready', () =&gt; { this.Server.authenticate = authenticate this.Server.authorizePublish = authorizePublish this.Server.authorizeSubscribe = authorizeSubscribe logger.info('Mosca MQTT Broker Service: Started') if (callback) { callback(null) } }) this.Server.on(&quot;error&quot;, function (err) { logger.error(err) }) this.Server.on('clientConnected', (client) =&gt; { logger.info('MQTTS: Client Connected:', client.id) this.clientDisconnectCallbacks[client.id] = [] }) this.Server.on('clientDisconnected', (client) =&gt; { logger.info('MQTTS: Client Disconnected:', client.id) if (this.clientDisconnectCallbacks.hasOwnProperty(client.id)) { while (this.clientDisconnectCallbacks[client.id].length &gt; 0) { (this.clientDisconnectCallbacks[client.id].shift())() } delete this.clientDisconnectCallbacks[client.id] } }) /* server.on('published', function (packet, client) { //logger.debug(&quot;Published :=&quot;, packet) }) server.on('subscribed', function (topic, client) { //logger.debug(&quot;Subscribed :=&quot;, client.packet) }) server.on('unsubscribed', function (topic, client) { //logger.debug('unsubscribed := ', topic) }) server.on('clientDisconnecting', function (client) { //logger.debug('clientDisconnecting := ', client.id) }) */ }, /** * MQTT Server Stop Service * @method * @param {function} callback - Callback when service is and conneciton is clear. */ stopService(callback) { if(this.Server){ logger.info('Mosca MQTT Broker Service: Stopping') this.Server.close(() =&gt; { this.Server = null if (callback) { callback() } }) } else { if(callback) { callback() } } }, } × Search results Close "},"modules_web.js.html":{"id":"modules_web.js.html","title":"Source: modules/web.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: modules/web.js const express = require('express') const path = require('path') const bodyParser = require('body-parser') const cors = require('cors') const fs = require('fs') const os = require('os') const http = require('http') const https = require('https') const WebSocket = require('ws') const url = require('url') const config = require('../config/config') const passport = require('passport') const compression = require('compression') const logger = require('./logger') const helpers = require('./helpers') /** * REST Web Interface Module * @module modules/web * @version 2.0 */ module.exports = { Server: null, wsServer: null, logWS: [], /** * Express Start Web API Service and add routes. * @method */ startService() { if (!this.Server) { const app = express() const frontend = require('../routes/frontend') const rest = require('../routes/rest') // Port Number const port = config.settings.listenPort || 3000 // Compression to gzip app.use(compression()) // CORS Middleware app.use(cors()) //app.use(logger.debug) // Set Static Folder const staticFolder = path.join(__dirname, '../../public/') app.use(express.static(staticFolder)) // Body Parser Middleware app.use(bodyParser.json()) // Passport Middleware app.use(passport.initialize()) app.use(passport.session()) require('../config/passport')(passport) // /Users Routes app.use('/frontend/', frontend) app.use('/ns/', rest) // Error Handling app.use(function(err, req, res, next) { res.status(err.status || 500) res.json({'error': { message: err.message, error: err }}) }) // Index Route app.get('*', (req, res) =&gt; { res.sendFile(staticFolder + 'index.html') }) try { if (config.settings.useHttps) { // Get SSL Keys from settings const ssl_options = { key: config.settings.sslData['private'], cert: config.settings.sslData['cert'], rejectUnauthorized: false, requestCert: false } // ForceSSL on every page. //app.use(forceSSL) this.Server = https.createServer(ssl_options, app) //this.Server = http.createServer(app) } else { this.Server = http.createServer(app) } // Start Server this.Server.listen(port, () =&gt; { logger.info('HTTP Interface Service: Started - Port: ' + this.Server.address().port) config.settings.listenPort = this.Server.address().port config.settings.save() }) .on('error', (err) =&gt; { if (err.code === 'EADDRINUSE') { logger.info('HTTP Server: Port ' + port + ' in use. Finding open port.') this.Server.listen() } }) } catch (e) { logger.debug(e) } /* this.wsServer = new WebSocket.Server({ perMessageDeflate: false, server: this.Server, clientTracking: true }) this.wsServer.on('connection', (ws, req) =&gt; { const logFile = os.homedir() + '/.polyglot/log/debug.log' const location = url.parse(req.url, true) logger.debug('~~~~~~~~~~~' + JSON.stringify(location)) if (location.path === '/ws/udi/polyglot/log') { logger.debug('WS: Bulk dump of polyglot log file to frontend.') //This works 1000 times faster to stream it than bulk read it first var rs = fs.createReadStream(logFile) rs.on('data', (chunk) =&gt; { ws.send(chunk.toString('utf8')) }) rs.on('end', () =&gt; { Tail = require('tail').Tail tail = new Tail(logFile) tail.on('line', (data) =&gt; { if (ws.readyState === 1) { ws.send(data) } else { tail.unwatch() ws.terminate() } }) }) } }) this.wsServer.on('message', (message) =&gt; { }) */ } }, /** * Express Stop Web API Service and add routes. This is run on shutdown. * @method * @param {function} callback - Callback when complete. */ stopService(callback) { logger.info('HTTP Interface Service: Stopping') if (this.Server) { if (this.wsServer) { this.wsServer.close() } this.Server.close(() =&gt; { this.Server = null if(callback) { return callback() } }) } else { if(callback) { return callback() } } } } × Search results Close "},"routes_frontend.js.html":{"id":"routes_frontend.js.html","title":"Source: routes/frontend.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: routes/frontend.js const express = require('express') const router = express.Router() const passport = require('passport') const jwt = require('jsonwebtoken') const UserModel = require('../models/user') const SettingsModel = require('../models/settings') const NodeServerModel = require('../models/nodeserver') //const db = require('../modules/db') const config = require('../config/config') const helpers = require('../modules/helpers') const logger = require('../modules/logger') const mqtt = require('../modules/mqttc') /** * Frontend Interface Module * @module routes/frontend * @version 2.0 */ // Register route (unused currently) /* router.post('/register', (req, res, next) =&gt; { let newUser = new UserModel({ username: req.body.username, password: req.body.password }) UserModel.addUser(newUser, (err, user) =&gt; { if(err) { res.json({success: false, msg: 'Failed to register user' + err}) } else { res.json({success: true, msg: 'User registered'}) } }) }) */ /** Headers: Content-Type: application/json Body: {&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;} Response: {&quot;success&quot;: true, &quot;token&quot;: &quot;JWT TOKEN&quot;, &quot;user&quot;: {&quot;username&quot;: &quot;e42&quot;}} * @name authenticate * @route {POST} /frontend/authenticate */ router.post('/authenticate', (req, res, next) =&gt; { const username = req.body.username const password = req.body.password UserModel.getUserByUsername(username, (err, user) =&gt; { if (err) { return next(err) } if (!user) { return res.json({success: false, msg: 'User not found'}) } UserModel.comparePassword(password, user.password, (err, isMatch) =&gt; { if (err) { return next(err) } if (isMatch) { logger.info('Successful login by ' + user.username) const token = jwt.sign({data: user}, config.settings.secret, { expiresIn: 604800 // 1 week }) res.json({ success:true, token: 'JWT ' + token, user: { id: user.id, username: user.username } }) } else { return res.json({success: false, msg: 'Wrong Password'}) } }) }) }) /** Headers: Content-Type: application/json Authorization: JWT token Body: None Response: {&quot;user&quot;: {&quot;username&quot;: &quot;e42&quot;, &quot;password&quot;: &quot;$2a$10$fvKDD9EGoRrLUbfE7ypw9.DRPGmwbPoR.Zz7WecsKX4bb2UCZiZ22&quot;,}} * @name profile * @route {GET} /frontend/profile */ router.get('/profile', passport.authenticate('jwt', {session: false}), (req, res, next) =&gt; { res.json({ user: req.user }) }) /** Headers: Content-Type: application/json Authorization: JWT Token Body: {&quot;name&quot;: &quot;Test123&quot;, &quot;profileNum&quot;: 5} Response: {&quot;success&quot;: true,&quot;msg&quot;: &quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;, &quot;nodeserver&quot;: {&quot;name&quot;: &quot;Test123&quot;, &quot;profileNum&quot;: &quot;5&quot;}} * @name addns * @route {POST} /frontend/addns router.post('/addns', passport.authenticate('jwt', {session: false}), (req, res, next) =&gt; { NodeServerModel.addns(req.body.name, req.body.profileNum, (err, response) =&gt; { if (err) return next(err) else res.json(response) }) }) */ /** Headers: Content-Type: application/json Authorization: JWT Token Body: {&quot;profileNum&quot;: 5} Response: {&quot;success&quot;:true,&quot;msg&quot;:&quot;Test123(5): Succesfully removed NodeServer. You must reboot the ISY.&quot;} * @name delns * @route {POST} /frontend/delns router.post('/delns', passport.authenticate('jwt', {session: false}), (req, res, next) =&gt; { let profileNum = req.body.profileNum let currentNS = config.nodeServers[profileNum] if (currentNS) { currentNS.deleteNodeServer((err, message) =&gt; { if (err) { logger.error(`DeleteNodeServer: ${err}`) res.json({success: false, msg: err}) } else { mqtt.delSubscription(profileNum) NodeServerModel.sendUpdate() return res.json({success: true, msg: message}) } }) } else { let message = `NodeServer with Profile Number ${profileNum} does not exist.` logger.error(`${message}`) return res.json({success: false, msg: message}) } }) */ /** Headers: Content-Type: application/json Authorization: JWT Token Body: {&quot;settings&quot;:{&quot;listenPort&quot;:3000,&quot;ipAddress&quot;:&quot;10.0.0.75&quot;,&quot;mqttWSPort&quot;:8083,&quot;mqttPort&quot;:1883,&quot;mqttHost&quot;:&quot;127.0.0.1&quot;,&quot;isyVersion&quot;:&quot;5.0.10&quot;,&quot;isyHttps&quot;:false,&quot;isyHost&quot;:&quot;10.0.0.14&quot;,&quot;isyPort&quot;:80,&quot;isyUsername&quot;:&quot;admin&quot;}} Response: {&quot;success&quot;:true,&quot;msg&quot;:&quot;&quot;} * @name delns * @route {POST} /frontend/delns router.post('/settings', passport.authenticate('jwt', {session: false}), (req, res, next) =&gt; { let newSettings = {updatesettings: req.body} SettingsModel.updateSettings(newSettings, (err, settings) =&gt; { if (err) { return next(err) } settings._id = undefined settings.name = undefined config.settings = settings if (settings) { logger.debug('Settings updated.') helpers.restartServices() return res.json({success: true, msg: ''}) } else { return res.json({success: false, msg: 'Unable to save settings.'}) } }) }) router.get('/settings/reset', passport.authenticate('jwt', {session: false}), (req, res, next) =&gt; { SettingsModel.resetToDefault(newSettings, (err, settings) =&gt; { if (err) { return next(err) } if (settings) { helpers.restartServices() settings = JSON.parse(JSON.stringify(settings)) delete settings._id return res.json(settings) } }) }) */ /** Headers: Content-Type: application/json Authorization: JWT token Body: None Response: {&quot;isyHost&quot;:&quot;10.0.0.14&quot;,&quot;isyPort&quot;:&quot;80&quot;,&quot;isyUsername&quot;:&quot;admin&quot;,&quot;isyPassword&quot;:&quot;admin&quot;,&quot;isyHttps&quot;:&quot;false&quot;,&quot;mqttHost&quot;:&quot;10.0.0.17&quot;,&quot;mqttPort&quot;:&quot;1883&quot;,&quot;mqttWSPort&quot;:&quot;8083&quot;} * @name settings * @route {GET} /frontend/settings */ router.get('/settings', passport.authenticate('jwt', {session: false}), (req, res, next) =&gt; { cleanSettings = SettingsModel.cleanSettings() SettingsModel.sendUpdate() return res.json(cleanSettings) }) router.get('/nodeservers', passport.authenticate('jwt', {session: false}), (req, res, next) =&gt; { NodeServerModel.getAllNodeServers((err, docs) =&gt; { res.json(JSON.parse(JSON.stringify(docs))) }) }) router.get('/log/:id', passport.authenticate('jwt', {session: false}), (req, res, next) =&gt; { NodeServerModel.getAllNodeServers((err, docs) =&gt; { res.json(JSON.parse(JSON.stringify(docs))) }) }) module.exports = router × Search results Close "},"routes_rest.js.html":{"id":"routes_rest.js.html","title":"Source: routes/rest.js","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Source: routes/rest.js const express = require('express') const router = express.Router() const passport = require('passport') const jwt = require('jsonwebtoken') const logger = require('../modules/logger') const isy = require('../modules/isy') //const NodeServerModel = require('../models/nodeserver') const config = require('../config/config') /** * REST API Interface Module * @module routes/rest * @version 2.0 */ // Incoming from ISY router.param('id', (req, res, next, id) =&gt; { next() }) /** * Not Implemented yet * @name install * @route {GET} rest/id/install/profileNum */ router.get('/:id/install/:profileNum', (req, res, next) =&gt; { logger.debug(`REST: Received Install`) isy.restInstall(req, res) return res.json({success: true}) }) /** * base/nodes/nodeAddress/query[?requestId=requestId] * base/nodes/nodeAddress/status[?requestId=requestId] * nodeAddress of 0 means query all nodes * @name status * @route {GET} rest/id/nodes/nodeAddress/command */ router.get('/:id/nodes/:nodeAddress/:command', (req, res, next) =&gt; { logger.debug(`REST: ${req.params.command} recieved from ISY`) isy.restStatus(req, res) return res.json({success: true}) }) /** * base/add/nodes[?requestId=requestId] * @name addnodes * @route {GET} rest/id/add/nodes */ router.get('/:id/add/nodes', (req, res, next) =&gt; { logger.debug(`REST: Add Nodes`) return res.json({success: true}) }) //&lt;base&gt;/nodes/&lt;nodeAddress&gt;/report/remove //&lt;base&gt;/nodes/&lt;nodeAddress&gt;/report/rename?name=&lt;nodeName&gt; //&lt;base&gt;/nodes/&lt;nodeAddress&gt;/report/enable //&lt;base&gt;/nodes/&lt;nodeAddress&gt;/report/disable //&lt;base&gt;/nodes/&lt;nodeAddress&gt;/report/add/&lt;nodeDefId&gt;?primary=&lt;nodeAddress&gt;&amp;name=&lt;nodeName&gt; /** * base/id//nodes/report/command/nodeDefId/[?requestId=requestId] * @name report * @route {GET} base/id//nodes/report/command/nodeDefId/[?requestId=requestId] */ router.get('/:id/nodes/:nodeAddress/report/:command/:nodeDefId?', (req, res, next) =&gt; { logger.debug(`REST: report`) isy.restReport(req, res) return res.json({success: true}) }) //&lt;base&gt;/nodes/&lt;nodeAddress&gt;/cmd/&lt;command&gt; //&lt;base&gt;/nodes/&lt;nodeAddress&gt;/cmd/&lt;command&gt;/&lt;value&gt; //&lt;base&gt;/nodes/&lt;nodeAddress&gt;/cmd/&lt;command&gt;/&lt;value&gt;/&lt;uom&gt; //[?&lt;p1&gt;.&lt;uom1&gt;=&lt;val1&gt;&amp;&lt;p2&gt;...][requestId=&lt;requestId&gt;] /** * rest/id/nodeAddress/cmd/command/value/uom * @name command * @route {GET} rest/id/nodeAddress/cmd/command/value/uom */ router.get('/:id/nodes/:nodeAddress/cmd/:command/:value?/:uom?', (req, res, next) =&gt; { logger.debug(`REST: ${req.params.command} Command received from ISY for ${req.params.nodeAddress}`) isy.restCommand(req, res) if (req.query.requestId) { let data = { requestId: req.query.requestId, success: true } isy.handleRequest(req.params.id, data, 'request') } return res.json({success: true}) }) router.get('*', (req, res, next) =&gt; { logger.debug('REST: hit the catch all... should not happen.') logger.debug(req.params, req.query) return res.json({success: true}) }) module.exports = router × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Modules Classes DriverSchema NodeSchema NodeServerModel UserModel × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Classes Classes DriverSchema NodeSchema NodeServerModel UserModel × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel polyglot-v2 2.0.21 UDI Polyglot v2Polyglot is a Middleware between the Universal Devices ISY Home Automation device and any number of external devices and services. Polyglot v2 is built on the MEAN stack which is a production ready enterprise level code stack that includes: MongoDB (A NoSQL database engine that stores data in JSON formated 'documents') Express (NodeJS HTTP API server module) Angular.JS (Frontend framework developed by Google) NodeJS (Fully asynchronous server side version of Javascript) Using these tools, along with the MQTT messaging protocol, we have created a robust IoT powerhouse that can speak to any and every device available with open API standards using simple, straight-forward modules (NodeServers). While most of the previous code had been written in Python, the event loop driven Node.JS was chosen for this platform due to its asynchronous nature. Python or ANY language can still be used to develop a NodeServer with the standard API interface available. Installation instructionsSince Polyglot is an enterprise level application there are several steps to get it up and running, this will be an ongoing process in order to simplify it. These steps are outlined directly for the Raspberry Pi, specifically the 3 or 3b models which were used to test. This has also worked on the original Raspberry Pi (Armv6) as well. A pre-built script is here to do all the heavy lifting for you. This install procedure was tested using a clean install of Rasbian Stretch Lite. Version September 2017 at time of writing. To Install Using the script (This will do EVERYTHING for you): # Run the Install Script wget -qO - https://github.com/Einstein42/udi-polyglotv2/raw/master/scripts/install.sh | bashYou do NOT need to proceed with theses instructions if you ran the script above. This is all done for you. The manual steps are listed here as well. Steps overview: Install MongoDB Install Polyglot-v2 PrerequisitesMongoDB # Update your sources sudo apt-get update -qy # Install the MongoDB Server / git / Python3 / Curl sudo apt-get -qqy install mongodb-server git python3-pip python3-dev curl # Check MongoDB Status systemctl status mongodb ● mongodb.service - An object/document-oriented database Loaded: loaded (/lib/systemd/system/mongodb.service; enabled) Active: active (running) since Thu 2017-07-13 03:35:41 UTC; 25min ago Docs: man:mongod(1) Main PID: 431 (mongod) CGroup: /system.slice/mongodb.service └─431 /usr/bin/mongod --config /etc/mongodb.confPolyglotNow the good stuff. Let's install Polyglot! Login as the user that is going to run Polyglot (pi or whatever you choose). Polyglot does NOT need to be run as root! (PLEASE DO NOT RUN POLYGLOT AS ROOT) # Create a polyglot directory mkdir polyglot # Enter polyglot directory cd polyglot # Get the Polyglot binary. This example is for armv7 Raspberry Pi 3/3b. (armv6 is RPi 1/Nano and x64 is most x86 linux boxes) # If you don't know which one to get run the command 'lscpu' and look at the top line. 'Architecture' wget -q https://github.com/Einstein42/udi-polyglotv2/raw/master/binaries/polyglot-v2-linux-armv7.tar.gz # Extract the archive tar -zxf polyglot-v2-linux-armv7.tar.gz # Run Polyglot normally: ./polyglot-v2-linux-armv7 # OR # Run Polyglot with debug logging turned on: NODE_ENV=development ./polyglot-v2-linux-armv7To start Polyglot on Boot do the following: # Get base systemd script from the GitHub repository wget -q https://github.com/Einstein42/udi-polyglotv2/raw/master/scripts/polyglot-v2.service # Edit it for your system nano polyglot-v2.service # Modify the following sections in the polyglot-v2.service file # Replace &lt;PWD&gt; with the current directory that the polyglot binary resides in. # Replace &lt;USER&gt; with the user you want polyglot to run as # Replace &lt;FILE&gt; with the FULL path to the polyglot binary. e.g. /home/pi/polyglot/polyglot-v2-linux-armv7 # One the above changes are done to the polyglot-v2.service file, move it to the systemd unit folder sudo mv polyglot-v2.service /lib/systemd/system/ # Add the service then start polyglot-v2 sudo systemctl enable polyglot-v2 sudo systemctl start polyglot-v2Verify that Polyglot is running # Check Polyglot status sudo systemctl status polyglot-v2.service ● polyglot-v2.service - polyglot-v2 Loaded: loaded (/lib/systemd/system/polyglot-v2.service; enabled) Active: active (running) since Thu 2017-07-13 04:38:53 UTC; 10min ago Main PID: 1647 (node) CGroup: /system.slice/polyglot-v2.service └─1647 node /usr/local/bin/polyglot-v2 Jul 13 04:38:53 raspberrypi systemd[1]: Started polyglot-v2.Default username and password are both admin Logs are located at ~/.polyglot/log/debug.log # Watch the logs real-time tail -f ~/.polyglot/log/debug.log 7/13/2017, 4:24:15 AM - info: Starting Polyglot version 2.0 7/13/2017, 4:24:15 AM - info: MongoDB: Connected 7/13/2017, 4:24:16 AM - info: MQTT Services Started. 7/13/2017, 4:24:16 AM - info: Secure Server started on port 3000 7/13/2017, 4:24:16 AM - info: ISY: Got Version 5.0.10 7/13/2017, 4:24:16 AM - info: MQTT: Subscribe Successful udi/polyglot/connections/# QoS: 0 7/13/2017, 4:24:38 AM - info: Successful login by admin 7/13/2017, 4:24:39 AM - info: MQTT: Frontend Websockets interface Connected.Enable debug logging for Polyglot # Edit the ~/.polyglot/.env file nano ~/.polyglot/.env # Add or modify the NODE_ENV variable NODE_ENV=developmentDevelopment DocumentationIt is pre-built in the docs folder Found Here on GitHub in HTML format if you clone the repository or available in theOnline Documentation Found Here. Prebuilt Python3 interface API for building NodeServers is here. NodeJS interface API for building NodeServers is coming soon. × Search results Close "},"module-config_config.html":{"id":"module-config_config.html","title":"Module: config/config","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: config/config Config data pulled from the .env fileand some globally accessible internal variables Version: 2.0 Source: config/config.js, line 1 Members &lt;static&gt; dbConnected :boolean MongoDB is connected True/False Type: boolean Source: config/config.js, line 17 &lt;static&gt; dotenv :Object dotenv is an Object of the key value pairs from ~/.polyglot/.env Type: Object Source: config/config.js, line 12 &lt;static&gt; mqttConnected :boolean MQTT is connected True/False Type: boolean Source: config/config.js, line 22 &lt;static&gt; nodeServers :Array Array of NodeServerModel objects kept in resident memory as reflection of their database models.This allows for direct calling of NodeServerModel objects via nodeServers[profileNum]. The Array indexcorrelates to the NodeServer profileNum for ease of use. e.g. LiFX nodeserver with the profileNum of 8can be called via nodeServers[8].save() to save the NodeServer changes to the db for example. Type: Array Source: config/config.js, line 31 &lt;static&gt; settings :Object Settings Loaded from the ~/.polyglot/.env file using the dotenv NodeJS module. You SHOULD NEVER MODIFY THIS IN THE SOURCE. Just use the .env isyHost = '192.168.1.10' isyPort = '80' isyUsername = 'admin' isyPassword = 'password' isyHttps = true/false (This isn't tested yet) mqttHost = '192.168.1.12' (This CANNOT be 'localhost' or '127.0.0.1' as it is passed to the frontend for websocket connections. IT MUST BE THE HOST IP) mqttPort = '1883' (Default is 1883) mqttWSPort = '8083' (Default is 8083) Type: Object Source: config/config.js, line 44 &lt;static&gt; sslKey SSL Key and Cert Data, read at startup from ~/.polylot/ssl/ using the files polyglot.crt and polyglot.key Source: config/config.js, line 48 × Search results Close "},"module-config_passport.html":{"id":"module-config_passport.html","title":"Module: config/passport","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: config/passport The passport module to wrap all authenticated functionsthat require the token to be accessed. (require(&quot;config/passport&quot;))(passport) Function to create the JWT Strategy for Passport. Parameters: Name Type Description passport module The Passport module is passed in to create a new JwtToken Strategy for authentication via header tokens. Source: config/passport.js, line 18 × Search results Close "},"module-models_nodeserver.html":{"id":"module-models_nodeserver.html","title":"Module: models/nodeserver","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: models/nodeserver NodeServer Model and Parent Class. AddNS uses 'new NodeServerModel' to reference the NodeServerSchema parent class to create a new MongoDB document via Mongoose Version: 2.0 Source: models/nodeserver.js, line 14 Classes DriverSchema NodeSchema NodeServerModel Methods &lt;static&gt; NodeServerModel.addns(name, profileNum, callback) Frontend called method to add a new NodeServer Parameters: Name Type Description name string Name of NodeServer being added profileNum number Profile Number of NodeServer being added callback addnsCallback Callback with response JSON Source: models/nodeserver.js, line 187 Returns: response - AddNS: {&quot;addns&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;},&quot;seq&quot;:53407} Success: {&quot;seq&quot;:53407,&quot;response&quot;:{&quot;success&quot;:true,&quot;msg&quot;:&quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;,&quot;nodeserver&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;}}} Fail: {&quot;seq&quot;:53408,&quot;response&quot;:{&quot;success&quot;:false,&quot;msg&quot;:&quot;NodeServer with that Profile Number already exists.&quot;}} Type object &lt;static&gt; NodeServerModel.checkExistingNodeServers(callback) Check all the existing slots in the ISY for NodeServers. Parameters: Name Type Description callback function Callback with an Object of NodeServers currently installed in ISY. { 1: 'LiFX', 5: 'Nest' } Source: models/nodeserver.js, line 647 &lt;static&gt; NodeServerModel.getAllNodeServers(callback) Get all NodeServers from MongoDB Parameters: Name Type Description callback findArrayCallback Callback Passed into the Mongoose find method. Source: models/nodeserver.js, line 572 Returns: Type findArrayCallback &lt;static&gt; NodeServerModel.getNodeByName(name, callback) Get NodeServer from MongoDB by Name Parameters: Name Type Description name string Name of Node requested from MongoDB callback findCallback Callback Passed into the Mongoose find method. Source: models/nodeserver.js, line 585 Returns: Type findCallback &lt;static&gt; NodeServerModel.getNodeByProfileNum(number, callback) Get NodeServer from MongoDB by profileNum Parameters: Name Type Description number number profileNum of Node requested from MongoDB callback findCallback Callback Passed into the Mongoose find method. Source: models/nodeserver.js, line 599 Returns: Type findCallback &lt;static&gt; NodeServerModel.loadNodeServers(callback) Load all NodeServers from MongoDB on Polyglot Start-up Parameters: Name Type Description callback errOnlyCallback Callback returned when complete Source: models/nodeserver.js, line 611 &lt;static&gt; NodeServerModel.parseFrontend(message) Parse incoming Frontend messages Parameters: Name Type Description message Object Incoming JSON parsed object from the frontend. Only commands accepted are 'addns' and 'delns' currently Source: models/nodeserver.js, line 341 &lt;static&gt; NodeServerModel.parseLog(message) Parse incoming log request messages Parameters: Name Type Description message Object Incoming JSON parsed object from the frontend. Only commands accepted are 'addns' and 'delns' currently Source: models/nodeserver.js, line 255 &lt;static&gt; NodeServerModel.readLogAndSend(node, name, logFile) Read Log File and send to frontend client. Parameters: Name Type Description node String Node Name of frontend client. name String Common Name of Node Server eg. LiFX logFile String Exact path to logfile Source: models/nodeserver.js, line 294 &lt;static&gt; NodeServerModel.removeLog(clientId, tail) Read Log File and send to frontend client. Parameters: Name Type Description clientId String Client ID of frontend client. tail Object The tail instance of the logfile. Source: models/nodeserver.js, line 329 &lt;static&gt; NodeServerModel.sendUpdate() Sends an update to the frontend topic on detection of a change in NodeServer properties or sub properties like driver updates or state changes. Source: models/nodeserver.js, line 166 Returns: response - MQTT Message sent to the frontends. e.g.: {&quot;nodeservers&quot;:[{&quot;name&quot;:&quot;LiFX&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;nodes&quot;:[{&quot;address&quot;:&quot;lifx_1234&quot;,&quot;name&quot;:&quot;LIFX_Lamp&quot;,&quot;_id&quot;:&quot;59338d1c2930bf7cc92842d1&quot;,&quot;drivers&quot;: [{&quot;driver&quot;:&quot;ST&quot;,&quot;_id&quot;:&quot;59338624cd92117adb9349ca&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;123.3&quot;},{&quot;driver&quot;:&quot;GV5&quot;,&quot;_id&quot;:&quot;59338624cd92117adb9349c9&quot;,&quot;uom&quot;:23,&quot;value&quot;:&quot;10&quot;}], &quot;isprimary&quot;:true,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496550684087&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true},{&quot;address&quot;:&quot;lifx_1235&quot;, &quot;name&quot;:&quot;Z_Strip&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d941&quot;,&quot;drivers&quot;: [{&quot;driver&quot;:&quot;ST&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d943&quot;,&quot;uom&quot;:56,&quot;value&quot;:&quot;593.3&quot;}, {&quot;driver&quot;:&quot;GV1&quot;,&quot;_id&quot;:&quot;59339445c67c877e13e4d942&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:false,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496552508813&quot;, &quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true}],&quot;token&quot;:null,&quot;encryptPayload&quot;:false,&quot;time_added&quot;:&quot;1496545371618&quot;,&quot;isConnected&quot;:true}]} Type object &lt;static&gt; NodeServerModel.verifyNonManagedNodeServers() Check all the existing slots in the ISY for NodeServers and add or remove them from our running database on Polyglot. Source: models/nodeserver.js, line 683 &lt;static&gt; NodeServerModel.verifyNonManagedNodeServers() Started on Initial DB load on program init. This polls the NodeServer list on ISY every 60 seconds and syncs. Source: models/nodeserver.js, line 718 Type Definitions addnsCallback(error, response) Parameters: Name Type Description error string An Error if returned response Object {&quot;seq&quot;:53407,&quot;response&quot;:{&quot;success&quot;:true,&quot;msg&quot;:&quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;,&quot;nodeserver&quot;:{&quot;name&quot;:&quot;Test123&quot;,&quot;profileNum&quot;:&quot;10&quot;}}} Source: models/nodeserver.js, line 1472 errOnlyCallback(error) Parameters: Name Type Description error string An Error if encountered Source: models/nodeserver.js, line 1490 findArrayCallback(error, documents) Parameters: Name Type Description error string An Error if encountered documents Object Array of documents returned by Mongoose Find Source: models/nodeserver.js, line 1478 findCallback(error, document) Parameters: Name Type Description error string An Error if encountered document Object Document returned by Mongoose FindOne Source: models/nodeserver.js, line 1484 responseCallback(error, response) Parameters: Name Type Description error string An Error if encountered response Object Object response returned to callback if no error occurred. Source: models/nodeserver.js, line 1495 × Search results Close "},"module-models_nodeserver-DriverSchema.html":{"id":"module-models_nodeserver-DriverSchema.html","title":"Class: DriverSchema","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Class: DriverSchema models/nodeserver~ DriverSchema new DriverSchema(driver, value, uom) MongoDB - Driver Child Schema Parameters: Name Type Description driver string Driver Name e.g. 'ST', 'RR', 'GV1', etc value string String representation of the value of the driver. uom number Integer of the UOM representing the value of the driver. Source: models/nodeserver.js, line 20 Extends NodeSchema × Search results Close "},"module-models_nodeserver-NodeSchema.html":{"id":"module-models_nodeserver-NodeSchema.html","title":"Class: NodeSchema","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Class: NodeSchema models/nodeserver~ NodeSchema new NodeSchema(address, added, enabled, name, node_def_id, time_added, primary, isprimary, drivers) MongoDB - Nodes Child Schema Parameters: Name Type Description address string Node address value e.g. 'lifxcontrol' added boolean Represents if the node is added and present in the ISY. enabled boolean Represents the enabled state of the node. name string Descriptive name of the node. node_def_id string Node Definition ID represented in the profile.zip for this node type. time_added string DateString in epoch of when the node was added to Polyglot primary string The node address of the nodes primary parent node. This could be itself in some cases. isprimary boolean Is this node a primary for other nodes. drivers Object Array of DriverSchema Objects Source: models/nodeserver.js, line 43 Extends NodeServerModel × Search results Close "},"module-models_nodeserver-NodeServerModel.html":{"id":"module-models_nodeserver-NodeServerModel.html","title":"Class: NodeServerModel","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Class: NodeServerModel models/nodeserver~ NodeServerModel new NodeServerModel(name, profileNum, encryptPayload, token, time_added, isConnected, logPrefix, nodes) MongoDB - NodeServer Parent Schema for creating a new NodeServer Database Object Parameters: Name Type Description name string NodeServer name that is displayed in Polyglot. e.g. 'LiFX' or 'Nest' profileNum string ProfileNumber of the NodeServer. This must be a unique number between 1 - 10 that is not already defined in ISY. encryptPayload boolean Should we encrypt the payload using our .env secret? [NOT IMPLEMENTED YET] token string Encryption token taken from the .env file and saved to the DB [NOT IMPLEMENTED YET] time_added string DateString in epoch of when the NodeServer was added to Polyglot isConnected boolean Is Polyglot Connected to MQTT? logPrefix string Allows for custom logPrefixes to be defined per NodeServer if needed. nodes Object Array of NodeSchema Objects Source: models/nodeserver.js, line 93 Methods addnode(data, command) Instance Method for NodeServer to handle 'addnode' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;nodes&quot;: [{&quot;address&quot;: &quot;lifx_1236&quot;,&quot;name&quot;: &quot;LIFX_Lamp2&quot;,&quot;node_def_id&quot;: &quot;lifxcolor&quot;,&quot;primary&quot;: &quot;lifx_1234&quot;,&quot;drivers&quot;: [{&quot;driver&quot;: &quot;ST&quot;,&quot;value&quot;: &quot;123.3&quot;,&quot;uom&quot;: 20},{&quot;driver&quot;: &quot;GV5&quot;,&quot;value&quot;: &quot;10&quot;,&quot;uom&quot;: 23}]}], &quot;seq&quot;: 1000} command string The command received: 'addnode' Source: models/nodeserver.js, line 878 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:1000,&quot;elapsed&quot;:&quot;100.425214ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;node lifx_1236 added successfully.&quot;,&quot;address&quot;:&quot;lifx_1236&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;25.251796ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1235 already exists on ISY&quot;,&quot;address&quot;:&quot;lifx_1235&quot;}}} Type object checkCommand() Instance Method for NodeServer to check input from MQTT and execute function if successful.Valid Commands: ['status', 'addnode','removenode', 'restcall', 'request', 'config', 'connected', 'command'] Source: models/nodeserver.js, line 742 command(data, command) Instance Method for NodeServer to handle 'command' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;command&quot;: &quot;DON&quot;, &quot;value&quot;: 50.2, &quot;uom&quot;: 20} command string The command received: 'command' Source: models/nodeserver.js, line 821 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;true&quot;,&quot;status&quot;:&quot;200&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;0&quot;}}},&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;19.073624ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;command&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;lifx_1234 DON sent sucessfully with 50.2&quot;,&quot;address&quot;:&quot;lifx_1234&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;400&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;2101&quot;}}},&quot;statusCode&quot;:400,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;10.852264ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;command&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_123 or asdf does not exist or is incorrect&quot;,&quot;address&quot;:&quot;lifx_123&quot;}}} Type object config(data, command) Instance Method to handle 'config' from NodeServer Parameters: Name Type Description data Object {&quot;node&quot;: &quot;1&quot;, &quot;config&quot;: null, &quot;seq&quot;: 1000} command string This command 'config'. Source: models/nodeserver.js, line 1370 Returns: response - Returns existing NodeServer configuration: {&quot;config&quot;:{&quot;name&quot;:&quot;LiFX&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;nodes&quot;:[{&quot;address&quot;:&quot;lifx_1234&quot;,&quot;name&quot;:&quot;LIFX_Lamp2&quot;,&quot;drivers&quot;:[{&quot;driver&quot;:&quot;ST&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;123.3&quot;},{&quot;driver&quot;:&quot;GV5&quot;,&quot;uom&quot;:23,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:true,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496550684087&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true},{&quot;address&quot;:&quot;lifx_1235&quot;,&quot;name&quot;:&quot;TouchMe&quot;,&quot;drivers&quot;:[{&quot;driver&quot;:&quot;ST&quot;,&quot;uom&quot;:56,&quot;value&quot;:&quot;593.3&quot;},{&quot;driver&quot;:&quot;GV1&quot;,&quot;uom&quot;:20,&quot;value&quot;:&quot;10&quot;}],&quot;isprimary&quot;:false,&quot;primary&quot;:&quot;lifx_1234&quot;,&quot;time_added&quot;:&quot;1496552508813&quot;,&quot;node_def_id&quot;:&quot;lifxcolor&quot;,&quot;enabled&quot;:true,&quot;added&quot;:true}],&quot;token&quot;:null,&quot;encryptPayload&quot;:false,&quot;time_added&quot;:&quot;1496545371618&quot;,&quot;isConnected&quot;:false}} Type Object connected(data, command) Instance Method to handle 'connected' from NodeServer Parameters: Name Type Description data Object {&quot;node&quot;: &quot;1&quot;, &quot;connected&quot;: true} or {&quot;node&quot;: &quot;1&quot;, &quot;connected&quot;: false} command string This command 'connected'. Source: models/nodeserver.js, line 1397 customparams(data, command) Instance Method for NodeServer to handle 'customparams' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;nodes&quot;: [{&quot;address&quot;: &quot;lifx_1236&quot;,&quot;name&quot;: &quot;LIFX_Lamp2&quot;,&quot;node_def_id&quot;: &quot;lifxcolor&quot;,&quot;primary&quot;: &quot;lifx_1234&quot;,&quot;drivers&quot;: [{&quot;driver&quot;: &quot;ST&quot;,&quot;value&quot;: &quot;123.3&quot;,&quot;uom&quot;: 20},{&quot;driver&quot;: &quot;GV5&quot;,&quot;value&quot;: &quot;10&quot;,&quot;uom&quot;: 23}]}], &quot;seq&quot;: 1000} command string The command received: 'addnode' Source: models/nodeserver.js, line 1417 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:1000,&quot;elapsed&quot;:&quot;100.425214ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;node lifx_1236 added successfully.&quot;,&quot;address&quot;:&quot;lifx_1236&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:200,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;25.251796ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;addnode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1235 already exists on ISY&quot;,&quot;address&quot;:&quot;lifx_1235&quot;}}} Type object deleteNodeServer(callback) Instance Method to delete this NodeServer from ISY automatically. This kicks off immediately after NodeServer is deleted via the frontend. Parameters: Name Type Description callback responseCallback (err, response) Callback when complete with error if present, or response if no error. Source: models/nodeserver.js, line 1243 getNodesFromISY(callback) Instance Method to Query for Nodes for this NodeServer from ISYThis happens at Polyglot Startup to Sync the ISY and Polyglot Database Parameters: Name Type Description callback errOnlyCallback Callback when complete with only parameter being an error if there was one. Source: models/nodeserver.js, line 1094 installNodeServer(callback) Instance Method to install this NodeServer to ISY automatically. This kicks off immediately after NodeServer is added to Polyglot via the frontend. Parameters: Name Type Description callback responseCallback (err, response) Callback when complete with error if present, or response if no error. Source: models/nodeserver.js, line 1163 removenode(data, command) Instance Method for NodeServer to handle 'removenode' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;node&quot;: &quot;1&quot;, &quot;removenode&quot;: {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;seq&quot;: 1004}} command string The command received: 'removenode' Source: models/nodeserver.js, line 1020 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;true&quot;,&quot;status&quot;:&quot;200&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;0&quot;}}},&quot;statusCode&quot;:200,&quot;seq&quot;:1004,&quot;elapsed&quot;:&quot;99.309321ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;removenode&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;lifx_1235 removed successfully&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;403&quot;,&quot;reason&quot;:{&quot;code&quot;:&quot;5106&quot;}}},&quot;statusCode&quot;:403,&quot;seq&quot;:1004,&quot;elapsed&quot;:&quot;17.747168ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;removenode&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;Could not remove lifx_1234. It is the primary for another node.&quot;}}} Type object request(data, command) Instance Method to handle 'request' from NodeServer Parameters: Name Type Description data Object {&quot;node&quot;: &quot;8&quot;, &quot;request&quot;: {&quot;requestId&quot;: &quot;3949&quot;, &quot;success&quot;: true}} command string This command 'request'. Source: models/nodeserver.js, line 1341 Returns: result - Responds only on failure. Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:404,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;8.202375ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;request&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;ISY Returned 404 for request ID: 22&quot;,&quot;id&quot;:&quot;22&quot;}}} Type Object restcall(data, command) Instance Method for NodeServer to handle 'restcall' Parameters: Name Type Description data object JSON parsed from incoming message e.g. {&quot;api&quot;:&quot;nodes/n001_d073d51327cc&quot;,&quot;seq&quot;:10068,&quot;timeout&quot;:null} command string The command received: 'restcall' Source: models/nodeserver.js, line 850 Returns: response - Success: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;nodeInfo&quot;:{&quot;node&quot;:{&quot;flag&quot;:&quot;0&quot;,&quot;nodeDefId&quot;:&quot;lifxcolor&quot;,&quot;address&quot;:&quot;n001_d073d51327cc&quot;,&quot;name&quot;:&quot;LIFX Lamp&quot;,&quot;family&quot;:{&quot;instance&quot;:&quot;1&quot;,&quot;$t&quot;:&quot;10&quot;},&quot;parent&quot;:{&quot;type&quot;:&quot;1&quot;,&quot;$t&quot;:&quot;n001_lifxcontrol&quot;},&quot;type&quot;:&quot;1.1.0.0&quot;,&quot;enabled&quot;:&quot;true&quot;,&quot;deviceClass&quot;:&quot;0&quot;,&quot;wattage&quot;:&quot;0&quot;,&quot;dcPeriod&quot;:&quot;0&quot;,&quot;startDelay&quot;:&quot;0&quot;,&quot;endDelay&quot;:&quot;0&quot;,&quot;pnode&quot;:&quot;n001_lifxcontrol&quot;,&quot;ELK_ID&quot;:&quot;A07&quot;},&quot;properties&quot;:{}}},&quot;statusCode&quot;:200,&quot;seq&quot;:10068,&quot;elapsed&quot;:&quot;29.861932ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;restcall&quot;:{&quot;success&quot;:true,&quot;reason&quot;:&quot;nodes/n001_d073d51327cc executed sucessfully&quot;,&quot;api&quot;:&quot;nodes/n001_d073d51327cc&quot;}}} Fail: {&quot;result&quot;:{&quot;isyresponse&quot;:{&quot;RestResponse&quot;:{&quot;succeeded&quot;:&quot;false&quot;,&quot;status&quot;:&quot;404&quot;}},&quot;statusCode&quot;:404,&quot;seq&quot;:10068,&quot;elapsed&quot;:&quot;15.433125ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;restcall&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;ISY Returned 404 for nodes/n001_d073d51327c&quot;,&quot;api&quot;:&quot;nodes/n001_d073d51327c&quot;}}} Type object sendResult(command, result, success, reason, extra) Instance Method to Send a result message to the NodeServer via MQTT Parameters: Name Type Description command string Command NodeServer is sending a result for. result Object The result object data. success boolean True/false reason string Sucess reason extra Object Extra Parameters to send to the NodeServer if needed. Source: models/nodeserver.js, line 1320 status(data, command) Instance Method for NodeServer to handle 'status' Parameters: Name Type Description data object JSON parsed from incoming command message e.g. {&quot;address&quot;: &quot;lifx_1234&quot;, &quot;driver&quot;: &quot;GV6&quot;, &quot;value&quot;: 50.2, &quot;uom&quot;: 20} command string The command received: 'status' Source: models/nodeserver.js, line 772 Returns: response - ONLY if an error occurs will a MQTT response message will be sent back to the NodeServer: {&quot;result&quot;:{&quot;isyresponse&quot;:&quot;&quot;,&quot;statusCode&quot;:404,&quot;seq&quot;:false,&quot;elapsed&quot;:&quot;9.735427ms&quot;,&quot;profileNum&quot;:&quot;8&quot;,&quot;status&quot;:{&quot;success&quot;:false,&quot;reason&quot;:&quot;lifx_1234 or GV18 does not exist&quot;,&quot;address&quot;:&quot;lifx_1234&quot;}}} Type object toJSON() Instance Method for NodeServer to return a JSON object of itself. Source: models/nodeserver.js, line 729 Returns: nodeserver - Returns JSON parsed Object representation of the NodeServer Type Object × Search results Close "},"module-models_user.html":{"id":"module-models_user.html","title":"Module: models/user","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: models/user User Model and Class. Version: 2.0 Source: models/user.js, line 6 Classes UserModel Methods &lt;static&gt; UserModel.addUser(newUser, callback) Adduser salts and hashes the password using bcrypt before saving it to the database. This has become problematic on older machines such as the Raspberry Pi 1.It is extremely slow to do the comparison. Gotta find a better way. Maybe less salts. Parameters: Name Type Description newUser Object new instance of UserModel callback saveCallback Callback Passed into the Mongoose find method. Source: models/user.js, line 67 &lt;static&gt; UserModel.addUser(password, callback) Compare salts and hashes with the password using bcrypt. This has become problematic on older machines such as the Raspberry Pi 1.It is extremely slow to do the comparison. Gotta find a better way. Maybe less salts. Parameters: Name Type Description password string Password attempting to authenticate with. callback compareCallback Callback Passed into the Mongoose find method. Source: models/user.js, line 88 &lt;static&gt; UserModel.getUserByUsername(username, callback) MongoDB gets user from database by Username. Parameters: Name Type Description username string Username to search for. callback findCallback Callback Passed into the Mongoose find method. Source: models/user.js, line 52 &lt;static&gt; UserModel.sendUpdate(id, callback) MongoDB gets user from database by ID. Parameters: Name Type Description id string ID to search for. callback findCallback Callback Passed into the Mongoose find method. Source: models/user.js, line 40 Type Definitions compareCallback(error, isMatch) Parameters: Name Type Description error string An Error if encountered isMatch boolean True/False is password hashed successfully with bcrypt. Source: models/user.js, line 126 findCallback(error, document) Parameters: Name Type Description error string An Error if encountered document Object Document returned by Mongoose FindOne Source: models/user.js, line 114 saveCallback(error, document) Parameters: Name Type Description error string An Error if encountered document Object Document returned if sucessfully saved by Mongoose save method Source: models/user.js, line 120 × Search results Close "},"module-models_user-UserModel.html":{"id":"module-models_user-UserModel.html","title":"Class: UserModel","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Class: UserModel models/user~ UserModel new UserModel(username, password) MongoDB - UserSchema for creating a new User Database Object Parameters: Name Type Description username string Username of new User password string Password of new User Source: models/user.js, line 12 × Search results Close "},"module-modules_db.html":{"id":"module-modules_db.html","title":"Module: modules/db","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/db Database Module Version: 2.0 Source: modules/db.js, line 10 Members &lt;static&gt; Server MongoDB Connection var Source: modules/db.js, line 17 Methods &lt;static&gt; startService(callback) MongoDB Start Service and Connect via .env MONGO_URI provided. Parameters: Name Type Description callback startCallback Callback when connected and all NodeServers were retrieved. Source: modules/db.js, line 24 &lt;static&gt; stopService(callback) MongoDB Stop Service run on program shutdown. Parameters: Name Type Description callback stopCallback Callback when shutdown or error. Source: modules/db.js, line 65 Type Definitions startCallback(error, documents) Parameters: Name Type Description error string An Error if encountered documents Object Documents returned if sucessfully connected and retrieved existing NodeServer documents. Source: modules/db.js, line 78 stopCallback(error) Parameters: Name Type Description error string An Error if encountered Source: modules/db.js, line 84 × Search results Close "},"module-modules_encryption.html":{"id":"module-modules_encryption.html","title":"Module: modules/encryption","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/encryption The encryption module to encrypt communications between NodeServers and Polyglotthis is tested, however it is not enabled as of release 2.0 Version: 2.0 Source: modules/encryption.js, line 6 Methods &lt;static&gt; decryptText(text) decryptText Parameters: Name Type Description text string Text to decrypt Source: modules/encryption.js, line 31 Returns: Decrypted Text Type string &lt;static&gt; encryptText(text) encryptText Parameters: Name Type Description text string Text to encrypt Source: modules/encryption.js, line 18 Returns: Encrypted Text Type string × Search results Close "},"module-modules_helpers.html":{"id":"module-modules_helpers.html","title":"Module: modules/helpers","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/helpers Generic Helpers Module that has a couple of various methods that didn't fit elsewhere. Version: 2.0 Source: modules/helpers.js, line 14 Methods &lt;static&gt; restartServices() restartServices is an external function to stop then restart the MQTT service and re-initiate a NodeServer Resync Source: modules/helpers.js, line 58 &lt;static&gt; resyncNodesToISY(callback) resyncNodesToISY wraps a couple of database/ISY checks to make sure the ISY and Local MongoDB are in sync. Parameters: Name Type Description callback function Simple callback function that returns on error or when function is complete. Source: modules/helpers.js, line 36 &lt;static&gt; saveNodeServers() saveNodeServers will cycle through all the NodeServers and save the current state to MongoDB. This occurrs automatically before shutdown. Source: modules/helpers.js, line 90 &lt;static&gt; shutdown() shutdown is the program stop function to terminate the application gracefully. Source: modules/helpers.js, line 75 × Search results Close "},"module-modules_isy.html":{"id":"module-modules_isy.html","title":"Module: modules/isy","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/isy ISY API Module for REST calls to the ISY Interfaces Version: 2.0 Source: modules/isy.js, line 10 Methods &lt;static&gt; addnode(profileNum, data, cmd) Handles the addnode calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 163 &lt;static&gt; addNodePrefix(profileNum, nod) Automactially adds the ISY Node Prefix onto the address before querying the API. Parameters: Name Type Description profileNum number The NodeServer profileNum. nod string The NodeServer address id Source: modules/isy.js, line 23 &lt;static&gt; command(profileNum, data, cmd) Handles the command calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 140 &lt;static&gt; getIsy(profileNum, url, seq, getText, callback) Performs the actual query to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum url string The URL created by makeNodeUrl or makeApiUrl seq number Sequence number to verify response on specific call getText boolean Get full response text from ISY and package it in the response. True/False callback function Simple (err, response) callback with the result success or fail. Source: modules/isy.js, line 69 &lt;static&gt; getVersion(callback) Handles the inital getVersion request to verify ISY connectivity Parameters: Name Type Description callback function Simple (err) callback if there is an error. Otherwise no parameters passed. We save the result in the config/config singleton. Source: modules/isy.js, line 231 &lt;static&gt; handleRequest(profileNum, data, command, getText, callback) Handles the Request from Polyglot calls TO the ISY and formats them appropriately based on type. Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. command string Command received to query to the ISY getText boolean Get full response text from ISY and package it in the response. True/False. Default is False callback function Simple (response) callback with the result success or fail. Source: modules/isy.js, line 102 &lt;static&gt; makeApiUrl(api, path_args) Creates the API URL to query ISY/rest/{api}/?{path_args} Parameters: Name Type Description api string The ISY API path to query path_args object Dictionary of path arguments appended to the URL. Source: modules/isy.js, line 34 &lt;static&gt; makeNodeUrl(profileNum, path, path_args) Creates the Node URL to query ISY/rest/ns/{profileNum}/{path}/?{path_args} Parameters: Name Type Description profileNum number The NodeServer profileNum path string The ISY path to query path_args object Dictionary of path arguments appended to the URL. Source: modules/isy.js, line 51 &lt;static&gt; removenode(profileNum, data, cmd) Handles the removenode calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 185 &lt;static&gt; request(profileNum, data, cmd) Handles the request calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 217 &lt;static&gt; restAddNodes(req, res) Handles the addnodes command from ISYNot implemented on the ISY side yet. Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 335 &lt;static&gt; restcall(profileNum, data, cmd) Handles the restcall calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 202 &lt;static&gt; restCommand(req, res) Handles the 'command' command from ISY and passes it to the NodeServer to exectue a command. e.g. DON/DOF/etc. Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 360 &lt;static&gt; restInstall(req, res) Handles the incoming install command from ISYNot Implemented from the ISY at the moment. (I can't get ISY to send me the command) Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 299 &lt;static&gt; restReport(req, res) Handles the report command from ISYNot implemented on the ISY side yet. Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 348 &lt;static&gt; restStatus(req, res) Handles the incoming status command from ISY and passes it along to the NodeServerThis handles the succesful response to ISY as well. Parameters: Name Type Description req object Express incoming request object.Params at req.paramsQuery vars at req.query res object Express response object. Source: modules/isy.js, line 312 &lt;static&gt; status(profileNum, data, cmd) Handles the status calls to ISY Parameters: Name Type Description profileNum number The NodeServer profileNum data string Data received for the type of query from MQTT. cmd string Command received to query to the ISY Source: modules/isy.js, line 122 × Search results Close "},"module-modules_logger.html":{"id":"module-modules_logger.html","title":"Module: modules/logger","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/logger Logger Module Version: 2.0 Source: modules/logger.js, line 6 Members &lt;inner&gt; logLevel Default log level is INFO. If .env parameter of NODE_ENV is set to to 'development' then we up the level to DEBUG Source: modules/logger.js, line 15 &lt;inner&gt; transports Default log level is INFO. If .env parameter of NODE_ENV is set to to 'development' then we log to the console as well as the file. Source: modules/logger.js, line 26 × Search results Close "},"module-modules_mqttc.html":{"id":"module-modules_mqttc.html","title":"Module: modules/mqttc","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/mqttc MQTT Client Module Version: 2.0 Source: modules/mqttc.js, line 5 Members &lt;static&gt; Client MQTT Client var Source: modules/mqttc.js, line 13 &lt;static&gt; clientId MQTT clientId var Source: modules/mqttc.js, line 15 Methods &lt;static&gt; addSubscription(profileNum) MQTT Addsubscription to new NodeServer Parameters: Name Type Description profileNum number add new subscription to NodeServer with profileNum. Source: modules/mqttc.js, line 96 &lt;static&gt; addSubscriptions() MQTT Addsubscriptions to Polyglot topics and existing NodeServer topics. Source: modules/mqttc.js, line 72 &lt;static&gt; makeResponse(topic, command, message) MQTT Make Response Parameters: Name Type Description topic string topic to publish to. Should be either 'connections' or the profileNum of the NodeServer command string Command to send, e.g 'status', etc. message object Dictionary object of message to send. JSON format. Source: modules/mqttc.js, line 147 &lt;static&gt; parse(topic, message) MQTT Parse incoming message from MQTT Parameters: Name Type Description topic string topic received on. message object Dictionary object of message. JSON parsed into object. Source: modules/mqttc.js, line 186 &lt;static&gt; publish(topic, message, options, callback) MQTT Once MakeResponse is complete, publish the message to MQTT Parameters: Name Type Description topic string topic to publish to. Should be either 'connections' or the profileNum of the NodeServer message object Dictionary object of message to send. JSON format. options object Typically used for {retain: True/False} to retain the last message. [Optional] callback function Callback when publish is complete. [Optional] Source: modules/mqttc.js, line 175 &lt;static&gt; startService(callback) MQTT Start Service and Connect via .env MQTT_HOST and MQTT_PORT provided. Parameters: Name Type Description callback function Callback when connected or if already started. Source: modules/mqttc.js, line 22 &lt;static&gt; stopService(callback) MQTT Stop Service Parameters: Name Type Description callback function Callback when service is and conneciton is clear. Source: modules/mqttc.js, line 127 × Search results Close "},"module-modules_mqtts.html":{"id":"module-modules_mqtts.html","title":"Module: modules/mqtts","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/mqtts MQTT Server Module Version: 2.0 Source: modules/mqtts.js, line 7 Members &lt;static&gt; Server MQTT Server var Source: modules/mqtts.js, line 15 Methods &lt;static&gt; startService(callback) MQTT Server Start Service. Parameters: Name Type Description callback function Callback when connected or if already started. Source: modules/mqtts.js, line 23 &lt;static&gt; stopService(callback) MQTT Server Stop Service Parameters: Name Type Description callback function Callback when service is and conneciton is clear. Source: modules/mqtts.js, line 127 × Search results Close "},"module-modules_web.html":{"id":"module-modules_web.html","title":"Module: modules/web","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: modules/web REST Web Interface Module Version: 2.0 Source: modules/web.js, line 18 Methods &lt;static&gt; startService() Express Start Web API Service and add routes. Source: modules/web.js, line 33 &lt;static&gt; stopService(callback) Express Stop Web API Service and add routes. This is run on shutdown. Parameters: Name Type Description callback function Callback when complete. Source: modules/web.js, line 143 × Search results Close "},"module-routes_frontend.html":{"id":"module-routes_frontend.html","title":"Module: routes/frontend","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: routes/frontend Frontend Interface Module Version: 2.0 Source: routes/frontend.js, line 14 Members &lt;route&gt; addns Route: MethodPath POST /frontend/addns Headers: Content-Type: application/json Authorization: JWT Token Body: {&quot;name&quot;: &quot;Test123&quot;, &quot;profileNum&quot;: 5} Response: {&quot;success&quot;: true,&quot;msg&quot;: &quot;Installed into ISY sucessfully. Reboot the ISY and upload the profile.zip&quot;, &quot;nodeserver&quot;: {&quot;name&quot;: &quot;Test123&quot;, &quot;profileNum&quot;: &quot;5&quot;}} Source: routes/frontend.js, line 90 &lt;route&gt; authenticate Route: MethodPath POST /frontend/authenticate Headers: Content-Type: application/json Body: {&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;} Response: {&quot;success&quot;: true, &quot;token&quot;: &quot;JWT TOKEN&quot;, &quot;user&quot;: {&quot;username&quot;: &quot;e42&quot;}} Source: routes/frontend.js, line 38 &lt;route&gt; delns Route: MethodPath POST /frontend/delns Headers: Content-Type: application/json Authorization: JWT Token Body: {&quot;profileNum&quot;: 5} Response: {&quot;success&quot;:true,&quot;msg&quot;:&quot;Test123(5): Succesfully removed NodeServer. You must reboot the ISY.&quot;} Source: routes/frontend.js, line 105 &lt;route&gt; delns Route: MethodPath POST /frontend/delns Headers: Content-Type: application/json Authorization: JWT Token Body: {&quot;settings&quot;:{&quot;listenPort&quot;:3000,&quot;ipAddress&quot;:&quot;10.0.0.75&quot;,&quot;mqttWSPort&quot;:8083,&quot;mqttPort&quot;:1883,&quot;mqttHost&quot;:&quot;127.0.0.1&quot;,&quot;isyVersion&quot;:&quot;5.0.10&quot;,&quot;isyHttps&quot;:false,&quot;isyHost&quot;:&quot;10.0.0.14&quot;,&quot;isyPort&quot;:80,&quot;isyUsername&quot;:&quot;admin&quot;}} Response: {&quot;success&quot;:true,&quot;msg&quot;:&quot;&quot;} Source: routes/frontend.js, line 134 &lt;route&gt; profile Route: MethodPath GET /frontend/profile Headers: Content-Type: application/json Authorization: JWT token Body: None Response: {&quot;user&quot;: {&quot;username&quot;: &quot;e42&quot;, &quot;password&quot;: &quot;$2a$10$fvKDD9EGoRrLUbfE7ypw9.DRPGmwbPoR.Zz7WecsKX4bb2UCZiZ22&quot;,}} Source: routes/frontend.js, line 76 &lt;route&gt; settings Route: MethodPath GET /frontend/settings Headers: Content-Type: application/json Authorization: JWT token Body: None Response: {&quot;isyHost&quot;:&quot;10.0.0.14&quot;,&quot;isyPort&quot;:&quot;80&quot;,&quot;isyUsername&quot;:&quot;admin&quot;,&quot;isyPassword&quot;:&quot;admin&quot;,&quot;isyHttps&quot;:&quot;false&quot;,&quot;mqttHost&quot;:&quot;10.0.0.17&quot;,&quot;mqttPort&quot;:&quot;1883&quot;,&quot;mqttWSPort&quot;:&quot;8083&quot;} Source: routes/frontend.js, line 172 × Search results Close "},"module-routes_rest.html":{"id":"module-routes_rest.html","title":"Module: routes/rest","body":" DocStrap Modules config/configconfig/passportmodels/nodeservermodels/usermodules/dbmodules/encryptionmodules/helpersmodules/isymodules/loggermodules/mqttcmodules/mqttsmodules/webroutes/frontendroutes/rest Classes models/nodeserver~DriverSchemamodels/nodeserver~NodeSchemamodels/nodeserver~NodeServerModelmodels/user~UserModel Module: routes/rest REST API Interface Module Version: 2.0 Source: routes/rest.js, line 11 Members &lt;route&gt; addnodes Route: MethodPath GET rest/id/add/nodes base/add/nodes[?requestId=requestId] Source: routes/rest.js, line 46 &lt;route&gt; command Route: MethodPath GET rest/id/nodeAddress/cmd/command/value/uom rest/id/nodeAddress/cmd/command/value/uom Source: routes/rest.js, line 76 &lt;route&gt; install Route: MethodPath GET rest/id/install/profileNum Not Implemented yet Source: routes/rest.js, line 22 &lt;route&gt; report Route: MethodPath GET base/id//nodes/report/command/nodeDefId/[?requestId base/id//nodes/report/command/nodeDefId/[?requestId=requestId] Source: routes/rest.js, line 61 &lt;route&gt; status Route: MethodPath GET rest/id/nodes/nodeAddress/command base/nodes/nodeAddress/query[?requestId=requestId]base/nodes/nodeAddress/status[?requestId=requestId]nodeAddress of 0 means query all nodes Source: routes/rest.js, line 33 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
